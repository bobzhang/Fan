#+OPTIONS: toc:nil html-postamble:nil html-preamble:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="stylesheets/styles.css" />
#+TITLE: Getting started
#+OPTIONS: ^:{}
#+OPTIONS: toc:t
#+TOC:headines 2



The following post assumes the reader is already familiar with OCaml.
If you are not familiar with OCaml, http://ocaml.org/ is recommended
for you to learn.


* Installation
  see [[file:install.org][Installation]]


* What language does Fan speak?

  Fan speaks OCaml natively, plus a few addons. 

  There are some minor differences between Fan's concrete syntax and
  OCaml though, the major differences is that Fan is more strict than
  OCaml.

  Three particular points:
  1. Parens are necessary for tuples
     #+BEGIN_SRC ocaml
       (** illegal *)
       a,b 
       let a,b = f in
           body
     #+END_SRC
     
     #+BEGIN_SRC ocaml
       (** correct syntax *)
       (a,b )
       let (a,b) = f in
           body
     #+END_SRC
  2. Parens or "begin" "end" necessary for semis
     #+BEGIN_SRC ocaml
       (* illegal *)
       print_endline "a"; print_endline "b" 
     #+END_SRC
     #+BEGIN_SRC ocaml
       (** correct *)
       (print_endline "a"; print_endline "b")
       begin print_endline "a"; print_endline "b" end
     #+END_SRC
  3. First vertical bar is necessary for algebraic data type, pattern
     match.
     #+BEGIN_SRC ocaml
       (** illegal *)
       type u = A | B
       let f = function
           A -> "a"
         | B -> "b"
       let f =
         match c with
           A -> "a"
         | B -> "b"
     #+END_SRC
     
     #+BEGIN_SRC ocaml
       (** correct *)
       type u =
         | A
         | B 
       
       let f = function
         | A -> "a"
         | B -> "b" 
       
       let f =
         match c with
         | A -> "a"
         | B -> "b"
           
     #+END_SRC
  4. $ is a reserved operator, please don't take it as a function.


* Compiing with Fan
  
** Hello world <<hello>>
    Create a file [[file:code/hello.ml][hello.ml]] as follows:

    #+INCLUDE:"./code/hello.ml" src ocaml :lines "1-3"

    The compile is quite simple, make sure =fan.byte= or =fan.native= is
    in your search path.

    #+BEGIN_SRC sh
      $ ocamlc -pp 'fan.native' hello.ml -o test
      $ ./test
    #+END_SRC

    As you may notice, adding ~-pp 'fan.native'~ flag is enough to
    switching to Fan. Using =fan.byte= or =fan.native= is up to you,
    for the time being, only the performance matters here. So,
    compiling with the following command line does also work.

    #+BEGIN_SRC sh
      $ ocamlc -pp 'fan.native' hello.ml -o test   
    #+END_SRC
    
** First class lexer

   Writing hello world is not very interesting, for the following
   example, we show you how DDSL fits into Fan. Suppose we want to
   write a lexical analyzier to filter nested comments in OCaml, the
   traditional way is to write a complex regex expression, or start a
   new file to write a lexer. The first way is hackish, inefficient,
   unmaintainable in the long run while the second way is too heavy
   weight, since lexer generator is a standard alone external DDSL which
   introduces another staging phase.

   Within Fan,  we show how easy it is now:
   #+INCLUDE: "./code/comment.ml" src ocaml :lines "1-27"

   Compiling is the same as the previous example [[hello]]

   #+BEGIN_SRC sh
     ocamlc -annot -pp 'fan.native' comment.ml -o comment   
   #+END_SRC

   Here we see the lexer DDSL is first class construct in Fan, the
   user don't need to create a new file to isolate their lexer, it's
   as convenient as regex expression in perl. So it works in
   toplevel, it works with module system, and objects, that said, the
   user could make lexer reusable by using [[http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html][objects]] instead of
   functions.

   Abot the internal of /lexer/ DDSL, see [[file:ddsl/lexer.org][DDSL:lexer]].

* Fan for toplevel 

** Playing with toplevel

   If you have ocamlfind installed, the easiest way to explore fan is
   starting the toplevel:

   #+BEGIN_SRC ocaml
     # #require "fan.top";;
     /Users/bobzhang1988/.opam/4.00.1/lib/fan: added to search path
     /Users/bobzhang1988/.opam/4.00.1/lib/fan/fanTop.cma: loaded
     # let a = {:exp-|3|};;
     val a : FAstN.exp = `Int "3"
   #+END_SRC
   Here "exp-" is a built-in DDSL for quasiquotation, see [[file:ddsl/quotation.org][DDSL:quotation]]
   
   There are two  directives added,

   1. normal
      #+BEGIN_SRC ocaml
        #normal;;      
      #+END_SRC
      This directive would restore the toplevel to the default
      behavior, it's useful sometimes, for examlpe, you want to load
      a normal ocaml file instead of file pre-processed by Fan.
   2. fan
      #+BEGIN_SRC ocaml
        #fan;;
      #+END_SRC
      It will turn on the featurs of fan.
      
      
** Playing with utop
  [[https://github.com/diml/utop][Utop]] is a toplevel with nice auto-completion support, it's very
  helpful for explore some libraries which the user is not familiar
  with.

  There is adapter for fan, namely ftop, available here:
  https://github.com/bobzhang/ftop
  
* Writing plugins for Fan

  There is a paper, which gives a high-level priciple about how Fan
  works, available here [[file:pdf/metaprogramming_for_ocaml.pdf]]

  
** Fan's quotation system 

   Fan's metaprogramming has a quotation system [[http://brion.inria.fr/gallium/index.php/Quotation][similar to Camlp4]].

   The differences lie in serveral following aspects


***  Concrete Syntax
     
     - For quotation, Fan uses ~{:quot@loc| |}~, while Camlp4 uses ~<:quot@< >>~
     - For antiquotation, Fan uses a single ~$~ or ~$(...)~, while Camlp4 uses ~$$~
     - Fan supports nested quasiquotation, while Camlp4 does not.
       The following quotation is legal  in Fan.
       #+BEGIN_SRC ocaml
       {:exp|{:exp| $($x) |}|}
       #+END_SRC
       Which is simliar to Common Lisp style macros.
       #+BEGIN_SRC lisp
         ``(,,x)       
       #+END_SRC
*** Abstract Syntax

*** polymorphic variants
    
*** location handling
    Fan encode abstract syntax using [[http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html][polymorphic variants]].
    From the user's point of view, Fan has two
    abstract syntax representations, with or without locations. They
    have exactly the same semantics except handling locations. The
    abstract syntax without location is derived from abstract syntax
    with location.
      
    For example, the definition of ~literal~ (in src/fAst.mli) are as follows:

    #+BEGIN_SRC ocaml
      (** literal with locations *)
      type literal =
        [ `Chr of (loc * string)
        | `Int of (loc * string)
        | `Int32 of (loc * string)
        | `Int64 of (loc * string)
        | `Flo of (loc * string)
        | `Nativeint of (loc * string)
        | `Str of (loc * string)]   
      
      
      (** literal without locations *)
      type literal =
        [ `Chr of string
        | `Int of  string
        | `Int32 of  string
        | `Int64 of string
        | `Flo of string
        | `Nativeint of string
        | `Str of string]      
      #+END_SRC
      
      Programming abstract syntax without caring about locations is way
      more easier. Location is important for debugging and meaningful
      error message, however, some scenarios, for example, code
      generation, don't need precise location.
      1. [ ] 

** Quotation DDSL

** Parser DDSL
