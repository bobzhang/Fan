(* include Arg; *)

(* let parse_argv ?(current = current) argv speclist anonfun errmsg = *)
(*   let l = Array.length argv in *)
(*   let b = Buffer.create 200 in *)
(*   let initpos = !current in *)
(*   let stop error = *)
(*     let progname = if initpos < l then argv.(initpos) else "(?)" *)
(*     in *)
(*       (match error with *)
(*        [ Unknown "-help" -> () *)
(*        | Unknown "--help" -> () *)
(*        | Unknown s -> bprintf b "%s: unknown option `%s'.\n" progname s *)
(*        | Missing s -> *)
(*            bprintf b "%s: option `%s' needs an argument.\n" progname s *)
(*        | Wrong opt arg expected -> *)
(*            bprintf b "%s: wrong argument `%s'; option `%s' expects %s.\n" *)
(*              progname arg opt expected *)
(*        | Message s -> bprintf b "%s: %s.\n" progname s ]; *)
(*        usage_b b speclist errmsg; *)
(*        if (error = (Unknown "-help")) || (error = (Unknown "--help")) *)
(*        then raise (Help (Buffer.contents b)) *)
(*        else raise (Bad (Buffer.contents b))) *)
(*   in *)
(*     (incr current; *)
(*      while !current < l do *)
(*        (\* let s = argv.(!current); *\) *)
(*        if ((String.length s) >= 1) && ((String.get s 0) = '-') *)
(*        then *)
(*          let action = *)
(*            try assoc3 s speclist with [ Not_found -> stop (Unknown s) ] *)
(*          in *)
(*            (try *)
(*               let rec treat_action = *)
(*                 fun *)
(*                 [ Unit f -> f () *)
(*                 | Bool f when (!current + 1) < l -> *)
(*                     let arg = argv.(!current + 1) *)
(*                     in *)
(*                       (try f (bool_of_string arg) *)
(*                        with *)
(*                        [ Invalid_argument "bool_of_string" -> *)
(*                            raise (Stop (Wrong s arg "a boolean")) ]; *)
(*                        incr current) *)
(*                 | Set r -> r.val := True *)
(*                 | Clear r -> r.val := False *)
(*                 | String f when (!current + 1) < l -> *)
(*                     (f argv.(!current + 1); incr current) *)
(*                 | Symbol symb f when (!current + 1) < l -> *)
(*                     let arg = argv.(!current + 1) *)
(*                     in *)
(*                       if List.mem arg symb *)
(*                       then (f argv.(!current + 1); incr current) *)
(*                       else *)
(*                         raise *)
(*                           (Stop *)
(*                              (Wrong s arg *)
(*                                 ("one of: " ^ (make_symlist "" " " "" symb)))) *)
(*                 | Set_string r when (!current + 1) < l -> *)
(*                     (r.val := argv.(!current + 1); incr current) *)
(*                 | Int f when (!current + 1) < l -> *)
(*                     let arg = argv.(!current + 1) *)
(*                     in *)
(*                       (try f (int_of_string arg) *)
(*                        with *)
(*                        [ Failure "int_of_string" -> *)
(*                            raise (Stop (Wrong s arg "an integer")) ]; *)
(*                        incr current) *)
(*                 | Set_int r when (!current + 1) < l -> *)
(*                     let arg = argv.(!current + 1) *)
(*                     in *)
(*                       (try r.val := int_of_string arg *)
(*                        with *)
(*                        [ Failure "int_of_string" -> *)
(*                            raise (Stop (Wrong s arg "an integer")) ]; *)
(*                        incr current) *)
(*                 | Float f when (!current + 1) < l -> *)
(*                     let arg = argv.(!current + 1) *)
(*                     in *)
(*                       (try f (float_of_string arg) *)
(*                        with *)
(*                        [ Failure "float_of_string" -> *)
(*                            raise (Stop (Wrong s arg "a float")) ]; *)
(*                        incr current) *)
(*                 | Set_float r when (!current + 1) < l -> *)
(*                     let arg = argv.(!current + 1) *)
(*                     in *)
(*                       (try r.val := float_of_string arg *)
(*                        with *)
(*                        [ Failure "float_of_string" -> *)
(*                            raise (Stop (Wrong s arg "a float")) ]; *)
(*                        incr current) *)
(*                 | Tuple specs -> List.iter treat_action specs *)
(*                 | Rest f -> *)
(*                     while !current < (l - 1) do f argv.(!current + 1); *)
(*                       incr current done *)
(*                 | _ -> raise (Stop (Missing s)) ] *)
(*               in treat_action action *)
(*             with [ Bad m -> stop (Message m) | Stop e -> stop e ]; *)
(*             incr current) *)
(*        else (try anonfun s with [ Bad m -> stop (Message m) ]; incr current) *)
(*        done); *)



(* let parse l f msg = *)
(*   try *)
(*     parse_argv Sys.argv l f msg; *)
(*   with *)
(*   [ Bad msg -> begin eprintf "%s" msg; exit 2 end *)
(*   | Help msg -> begin printf "%s" msg; exit 0 end]; *)
