(** Main signatures for Fan *)

open LibUtil;
open Ast;

type vrn =
    [ Sum 
    | TyVrnEq
    | TyVrnSup
    | TyVrnInf
    | TyVrnInfSup
    | TyAbstr ];
type trail_info = (vrn*int);

(* [collumn] meta data for the record *)
type col = {
    col_label:string;
    col_mutable:bool;
    col_ctyp:ctyp
  };

(* a series of [ast] nodes generated by the type *)
type ty_info = {
    name_exp: exp;
    (* [int] -> [meta_int] *)

    exp: exp;
    (* int -> [meta_int fmt x0] *)

    exp0: exp;
    (* ai *)
    pat0: pat;
    (* ai *)
    id_exp: exp ;
    (* (ai,bi) *)

    id_pat: pat;
    (* (ai,bi) *)

    id_exps: list exp;
    (* [ai;bi;ci] *)

    id_pats: list pat;
    (* [ai;bi;ci]*)

    ty: ctyp;
    (* int *) 
  }
;

type vbranch =
   [= `variant of (string* list ctyp)
   | `abbrev of ident ];
type branch =
   [= `branch of (string * list ctyp) ];
(* Feed to user to compose an expession node *)
type record_col = {
    re_label: string ;
    re_mutable: bool ;
    re_info: ty_info;
  };
type record_info = list record_col ;

(* types below are used to tell fan how to produce
   function of type [ident -> ident]
 *)
type basic_id_transform =
    [= `Pre of string
    | `Post of string
    | `Fun of id string ];

type rhs_basic_id_transform =
    [= basic_id_transform
    | `Exp of string -> exp ];

type full_id_transform =
    [=  basic_id_transform
    | `Idents of list ident  -> ident
    (* decompose to a list of ident and compose as an ident *)          
    | `Ident of ident -> ident
    (* just pass the ident to user do ident transform *)
    | `Last of string -> ident
    (* pass the string, and << .$old$. .$return$. >>  *)      
    | `Obj of id string ];

open StdLib;
open Objs;
{:fans|keep on; derive (Print); |};

{:ocaml|
type named_type = (string* (* ctyp *)typedecl)
and and_types =
    list named_type
and types =
    [= `Mutual of and_types
    | `Single of named_type ]
and module_types = list types;

type destination =
  [Obj of kind
  |Str_item]
and kind =
  [ Fold
  | Iter (* Iter style *) 
  | Map (* Map style *)
  | Concrete of ctyp];

type warning_type =
  [ Abstract of string 
  | Qualified of string ];
 
  |};

  
type plugin_name = string ;

type plugin = {
    transform:(module_types -> stru);
    (* activate: mutable bool; *)
    position: option string;
    filter: option (string->bool);
  };



(*
module type Config = sig
  val mk_variant:(string -> list ty_info  -> exp);
  val mk_tuple: (list ty_info -> exp );    
  val mk_record: (record_info -> exp);
  val arity: int;

  val left_type_variable: basic_id_transform;
  (* left type variable transformation
     ['a -> mf_a]
   *)  

  val right_type_variable: rhs_basic_id_transform;
  (* right type variable transformatoin.
     in most cases, it's similiar to var *)
    
  val right_type_id: full_id_transform;
  (* [t -> pp_print_t]  *)  

  val left_type_id: basic_id_transform;
  (* For structure_item generation, similar to
     right.
     Sometimes, it's not the same object, for example
     [t -> t]
   *)

  val trail: trail_info -> case;
  val names: list string;

  (* transforming the constructor name(it only has effect in the pattern part) *)  
  val cons_transform: option (string->string);  
end; 
*)


(* let string_of_warning_type = *)
(*   sprintf "Warning: %a\n" (fun _ -> *)
(*     fun *)
(*       [Abstract s -> "Abstract: " ^ s *)
(*       |Qualified s -> "Qualified: " ^ s] *)
(*                           ); *)
  

