#+TITLE: Fan: metaprogramming for OCaml
#+OPTIONS: toc:nil html-postamble:nil html-preamble:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="stylesheets/styles.css" />
#+BEGIN_HTML
<div class="wrapper">
<header>
<ul>
<li class="download"><a class="buttons" href="https://github.com/bobzhang/Fan/zipball/master">Download ZIP</a></li>
<li class="download"><a class="buttons" href="https://github.com/bobzhang/Fan/tarball/master">Download TAR</a></li>
<li><a class="buttons github" href="https://github.com/bobzhang/Fan">View On GitHub</a></li>
</ul>

<p class="header">Maintained by
<a class="header name" href="https://github.com/bobzhang">Hongbo Zhang</a>
</p>
</header>
<section>
#+END_HTML

[[https://github.com/bobzhang/Fan][Fan]] is a compile-time metaprogramming system for [[http://caml.inria.fr/][OCaml]], originally
inspired from [[http://brion.inria.fr/gallium/index.php/Camlp4][Camlp4]]. It's a combination of OCaml and Lispy
[[http://letoverlambda.com/][Macros]]. It shares the same concrete syntax with OCaml.


* Getting started 

  See here: [[file:start.org][Fan for beginners]], enjoy!
  

* Status 

  Please bear in mind that Fan is still at alpha release, so it's
  expected there would be many bugs. This also means that your
  participation is particularly important, and your suggestions will
  affect the design of Fan.



* Contributions

  Contributions are very welcome

  - [[https://github.com/bobzhang/Fan][Code repo]]

  - [[https://github.com/bobzhang/Fan/tree/gh-pages][Documentation repo]] 
    
    It's written in [[http://orgmode.org/][org-mode]] markup language.  If you are
    unfamiliar with org files, markdown or html patches are welcome as
    well.  Help on building the website is deeplhalso appreciated.
    
  - [[file:foo.docdir/index.html][Ocamldoc API]]


* Acknowledgments
  See [[file:credits.org][History]]

* COMMENT
  TODO List 

 - Porting Documentation on Camlp4 to Fan   

 - Native conditional compilation
    
 - Direct support for type-conv, or meta-conv 
   It's already in the repo, undocumented though.
    
 - Add eval support for byte code
   
 - Adding a directive language at the beginning of files

 - Backport Fan to OCaml 3.12

 - Scheme-style macros for local ast rewriting without computation
   

* COMMENT
  It shares the same run-time
with OCaml,

  By all means, master
   the spirit  of metaprogramming would 

  for example, function
   is the most basic concept in nearly all programming languages,
   
  Metaprogramming enables the possiblity for
   the  user to write least lines of code if they like. As a
   programmer, [[http://threevirtues.com/][being lazy]] should always be appreciated, we will show
   you some examples that metaprogramming can turn your tens lines of
   code into thousands of lines of code, simply put, metaprogramming
   is so invaluable that every practical programmer should master
   such technology. 

   That said, we need a macro system for your favorite programming
   language.  [[http://www.sbcl.org/][Common Lisp]] has been the best language for
   metaprogramming during the last decades.  However, as one of the
   eldest languages, there are some serious design defects for this
   language: first, it does not support separate compilation, there is
   no clear bound between compile-time runtime and
   
   Hmm, a good question, it's simply because writing
   boilerplate code is tedious and error prone, and 

   Having programming in [[http://en.wikipedia.org/wiki/Common_Lisp][Common Lisp]] for years, I
happened to find
[F#](http://research.microsoft.com/en-us/projects/fsharp/) when I
was doing an internship at Microsoft.  I was fascinated by the beauty
of functional languages, for example, the algebraic data type combined
with pattern match is superior to s-expression in some regards, and
strongly typed languages with type inference does help, especially
when you write large software and do the refactorization, a type
system is the  best tool for refactorization. XD.

   

   
#+BEGIN_HTML
</section>
</div>
#+END_HTML
