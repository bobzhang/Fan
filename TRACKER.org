


* DONE 01 lexer
  How to handle strings in quotation?

  Shall we treat them verbatim or impose some restrictions?
  the following quotations legal

  If we treat them verbatim the following is good (we may not like)
  {:lexer| "|}
  {:lexer| "agho |}

  If we treat only string specially, the following is wrong (should be
  a bug)
  {:lexer| '"' |}


  So to conclude, we should add some checks in quotation?

  how about this
  {:lexer| "|}" |}, if we treat them verbatim, this should fail.

  The problem becomes serious when handling nested quotations and
  anti-quotations:
     A sample code:

     #+BEGIN_SRC ocaml
       and quotation c = {:lexer|
         | '{' (':' quotation_name)? ('@' locname)? '|' (extra_quot as p)?
             ->
               begin
                 store c ;
                 Stack.push p opt_char; (* take care the order matters*)
                 with_curr_loc quotation c ;
                 parse quotation c
               end
         | (extra_quot as p)? "|}" ->
       ... |}     
     #+END_SRC

   The current solution is ad-hoc:
     It requires string to follow the ocaml convention, and for char,
     it has a loose requirement, it tries to recognize '"' problem,
     but
     does not prevent '    a' happen.
     #+BEGIN_SRC ocaml
           | "\"" {store c;
                   begin
                     try with_curr_loc string c
                     with FanLoc.Exc_located(_,Lexing_error Unterminated_string) ->
                       err Unterminated_string_in_quotation (loc_merge c)
                   end;
                   Buffer.add_char c.buffer '"';
                   parse quotation c
                 }
           | "'" ( [^ '\\' '\010' '\013'] | '\\' (['\\' '"' 'n' 't' 'b' 'r' ' ' '\'']
           | ['0'-'9'] ['0'-'9'] ['0'-'9'] |'x' hexa_char hexa_char)  as x) "'"
                  {store_parse quotation c }
     #+END_SRC


* DONE 02 illegal begin (ghost locatio horrible error message)

  When the parser raise "illegal begin " excpetion, the location is
  ghost a horrible error message.

  FIX
  



  
* 03 paser merge

  #+BEGIN_SRC caml
      (*
      FIXME:
      the merge does not work well with

      prefix:
      |-OPT [ "!"; `Uid _]---.
      `-OPT [ "!"; `Uid _]---stream_exp_comp_list---
      It's better to bring refine STree in the future,
      get rid of Action.t in most cases
     *)
  
  #+END_SRC

  
* DONE 04 class parser error

  This is not a bug :-), it's a build script bug in Fan, fixed now.
  can not parse... the class variable
  #+BEGIN_SRC caml
    class c_fold_pattern_vars ['accu] f init =  object
      inherit FanAst.fold as super
      val acc = init
      method acc : 'accu = acc
      method! pat = fun
        [ {:pat| $lid:s |} | {:pat| ~ $s |} | {:pat| ? $s |}
        -> {< acc = f s acc >}
      | p -> super#pat p ]
    end
  #+END_SRC


* 05 generate signatures for Objs module
  This will enhance separate compilation for the project


* 06 ast design

  #+BEGIN_SRC ocaml
    {| $vrn:cons of $par:t |}
    
    (* make `C to Vrn *)  
    `TyVrnOf(_loc, `C(_,cons), `Par(_,t))
  #+END_SRC

* DONE 07 Stream.Failure overrides the built-in Failure
  open Stream is dangerous...
  our ocamllex engine raises Failrue...
  solution: ==> failwith instead of Failure
  

* 08 generate fold type and map type in ml file and write them in mli file

* 09 Specialize [eoi_entry] and provide grammar analysis


* 10 EOI problem
  The lexer feeds an EOI at the end of stream, but most entries does
  not handle EOI, if handle EOI, some problem appears

  #+BEGIN_SRC ocaml
  exp_eoi:[ exp{e}; `EOI]
  #+END_SRC
  Given [`Ant; `EOI]
  exp:[
   `Ant  ->
   `Ant "g"; `Ant"ghso"
  ]
  will not parse, since under such case, the second production has a higher priority.


* 11 inling problem again

  #+BEGIN_SRC ocaml
    pat_as_pat_opt:
      [ pat{p1}; "as"; a_lident{s} ->  `Alias (_loc, p1, s)
      | pat{p} -> p ] 
    
    case0:
       [ `Ant (("case"|"" as n),s) -> mk_anti _loc ~c:"case" n s
       | pat_as_pat_opt{p}; "when"; exp{w};  "->"; exp{e} ->
          `CaseWhen (_loc, p, w, e)
       | pat_as_pat_opt{p}; "->";exp{e} -> `Case(_loc,p,e)]
  #+END_SRC
  can we simply inline [pat_as_pat_opt] here?  


* 12 with does not work with
  ident-
  with ident- is not parsed, the problem is the lexer.


* 13 a even light weight syntax 
  #+BEGIN_SRC ocaml
  | $a . $b => ghsog
  | ($a $b) => "ghos"
  | $lid:x =>
  | $uid:x => ....
  #+END_SRC
  

* 14 ctyp can parse uid
  

  #+BEGIN_SRC caml
    {:ctyp| A |}
    `Uid "A"
  #+END_SRC
  It's not easy to fix currently due to this grammar 

  #+BEGIN_SRC caml
           "." LA
            [ S{t1}; "."; S{t2} ->
                try
                  `Dot (_loc, (ident_of_ctyp t1 : ident), (ident_of_ctyp t2)) (* FIXME*)
                with Invalid_argument s -> raise (XStream.Error s) ]
      
  #+END_SRC


* 15 print generator
  Format.pp_print_string?


* 16 keep the code generation close with dumping
  make it easy to debug 


* DONE 17 a lesson while debug
  unit = `Uid "()"
  I used it as a type, and it type check...
  so strict type annotations are helpful
   unit : ep = `Uid "()"


* 18 method syntax in-compatible
  #+BEGIN_SRC caml
    method list : 'a . ?sep:space_formatter -> ?first:space_formatter ->
  #+END_SRC

* 19 make quotation first class, dual to Ant

* 20 rewrite hb script to make it work under windows

* DONE 21 avoid dependency on dynlink for toplevel
  dynlink should appear only in Fan, dynloader, makeBin
  core has a nice trick, but it requires c stubs..


  
* 22 synthesize the
  meta_int,.. in the compile time? to get rid of the dependency ?

  
* DONE 23 relax ipat

  now fan accepts such function

  #+BEGIN_SRC ocaml
    let pp_print_ant: Format.formatter -> FAst.ant -> unit =
      function fmt  (`Ant (_a0,_a1))  ->
        Format.fprintf fmt "@[<1>(`Ant@ %a@ %a)@]" pp_print_loc _a0
          FanUtil.pp_print_anti_cxt _a1
  #+END_SRC

  
* 24 include fans location problem

  How to avoid the location caused by include combined with filter
  

* DONE 25 get rid of dependency on ocamlfind
  ocamlfind should not appear in fan, we could split it into a sub
  package fan_utop which depends on ocamlfind

  
* 26 standard rts ?
  =FanUtil.float_reprs= needs to put some where or
  generated each time?
