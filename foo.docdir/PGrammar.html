<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="ParsetreeHelper.html">
<link rel="next" href="PreCast.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Ant" rel="Chapter" href="Ant.html">
<link title="AntN" rel="Chapter" href="AntN.html">
<link title="Ast2pt" rel="Chapter" href="Ast2pt.html">
<link title="AstFilters" rel="Chapter" href="AstFilters.html">
<link title="AstLibN" rel="Chapter" href="AstLibN.html">
<link title="AstMacros" rel="Chapter" href="AstMacros.html">
<link title="AstParsers" rel="Chapter" href="AstParsers.html">
<link title="AstPrint" rel="Chapter" href="AstPrint.html">
<link title="AstQuotation" rel="Chapter" href="AstQuotation.html">
<link title="BasicN" rel="Chapter" href="BasicN.html">
<link title="CodeTemplate" rel="Chapter" href="CodeTemplate.html">
<link title="CommentFilter" rel="Chapter" href="CommentFilter.html">
<link title="CtypN" rel="Chapter" href="CtypN.html">
<link title="DeriveN" rel="Chapter" href="DeriveN.html">
<link title="DynLoader" rel="Chapter" href="DynLoader.html">
<link title="EpN" rel="Chapter" href="EpN.html">
<link title="Exp" rel="Chapter" href="Exp.html">
<link title="ExpN" rel="Chapter" href="ExpN.html">
<link title="FanUtil" rel="Chapter" href="FanUtil.html">
<link title="FArg" rel="Chapter" href="FArg.html">
<link title="FAst" rel="Chapter" href="FAst.html">
<link title="FCMacroGen" rel="Chapter" href="FCMacroGen.html">
<link title="FConfig" rel="Chapter" href="FConfig.html">
<link title="FGramGen" rel="Chapter" href="FGramGen.html">
<link title="Fgram" rel="Chapter" href="Fgram.html">
<link title="Filters" rel="Chapter" href="Filters.html">
<link title="FLexer" rel="Chapter" href="FLexer.html">
<link title="FLexGen" rel="Chapter" href="FLexGen.html">
<link title="FLexLib" rel="Chapter" href="FLexLib.html">
<link title="FLoc" rel="Chapter" href="FLoc.html">
<link title="FSigUtil" rel="Chapter" href="FSigUtil.html">
<link title="FState" rel="Chapter" href="FState.html">
<link title="FStreamGen" rel="Chapter" href="FStreamGen.html">
<link title="Fsyntax" rel="Chapter" href="Fsyntax.html">
<link title="FToken" rel="Chapter" href="FToken.html">
<link title="Gcomb" rel="Chapter" href="Gcomb.html">
<link title="Gdelete" rel="Chapter" href="Gdelete.html">
<link title="Gentry" rel="Chapter" href="Gentry.html">
<link title="Gfailed" rel="Chapter" href="Gfailed.html">
<link title="Ginsert" rel="Chapter" href="Ginsert.html">
<link title="Gparser" rel="Chapter" href="Gparser.html">
<link title="Gprint" rel="Chapter" href="Gprint.html">
<link title="Gramlib" rel="Chapter" href="Gramlib.html">
<link title="Gstru" rel="Chapter" href="Gstru.html">
<link title="Gtools" rel="Chapter" href="Gtools.html">
<link title="IdN" rel="Chapter" href="IdN.html">
<link title="LangFans" rel="Chapter" href="LangFans.html">
<link title="LangInclude" rel="Chapter" href="LangInclude.html">
<link title="LangOcaml" rel="Chapter" href="LangOcaml.html">
<link title="LangSave" rel="Chapter" href="LangSave.html">
<link title="LexBackend" rel="Chapter" href="LexBackend.html">
<link title="LibUtil" rel="Chapter" href="LibUtil.html">
<link title="ParsetreeHelper" rel="Chapter" href="ParsetreeHelper.html">
<link title="PGrammar" rel="Chapter" href="PGrammar.html">
<link title="PreCast" rel="Chapter" href="PreCast.html">
<link title="PStream" rel="Chapter" href="PStream.html">
<link title="StdFan" rel="Chapter" href="StdFan.html">
<link title="TokenEval" rel="Chapter" href="TokenEval.html">
<link title="Typehook" rel="Chapter" href="Typehook.html">
<link title="XStream" rel="Chapter" href="XStream.html"><title>PGrammar</title>
</head>
<body>
<div class="navbar"><a class="pre" href="ParsetreeHelper.html" title="ParsetreeHelper">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="PreCast.html" title="PreCast">Next</a>
</div>
<h1>Module <a href="type_PGrammar.html">PGrammar</a></h1>
<pre><span class="keyword">module</span> PGrammar: <code class="code">sig</code> <a href="PGrammar.html">..</a> <code class="code">end</code></pre><div class="info">
The front-end of Fan's gram DDSL<br>
</div>
<hr width="100%">
<pre><span id="VALnonterminals"><span class="keyword">val</span> nonterminals</span> : <code class="type"><a href="FAst.html#TYPEstru">FAst.stru</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
<pre class="codepre"><code class="code">    with str t nonterminals {| U a b c d|}
    |&gt; Ast2pt.print_stru f;
    let a = U.mk "a"
    let b = U.mk "b"
    let c = U.mk "c"
    let d = U.mk "d"</code></pre>
    It is very simple, may be improved to a depend on a simple engine
    It is used by DDSL <code class="code">create</code><br>
</div>
<pre><span id="VALnonterminalsclear"><span class="keyword">val</span> nonterminalsclear</span> : <code class="type"><a href="FAst.html#TYPEexp">FAst.exp</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
<pre class="codepre"><code class="code">     with str t nonterminalsclear {| U a b c d|} |&gt; Ast2pt.print_exp f;
     U.clear a; U.clear b; U.clear c; U.clear d
    </code></pre>
    It's used by DDSL <code class="code">clear</code><br>
</div>
<pre><span id="VALdelete_rule_header"><span class="keyword">val</span> delete_rule_header</span> : <code class="type"><a href="FAst.html#TYPEvid">FAst.vid</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALextend_header"><span class="keyword">val</span> extend_header</span> : <code class="type">(<a href="FAst.html#TYPEvid">FAst.vid</a> option * <a href="FAst.html#TYPEvid">FAst.vid</a>) <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
parse the header, return the current <code class="code">grammar</code> and
     previous module name, it has side effect, and can not
     be used alone
     <pre class="codepre"><code class="code">     with str t extend_header {| U.M |};
     - : FAst.ident option * FAst.ident = (None, `Uid (, "Fgram"))
     with str t extend_header {| U |};
     - : FAst.ident option * FAst.ident =
     (None, `Dot (, `Uid (, "U"), `Uid (, "M")))
     with str t extend_header {| (g:U.t) |};
     - : FAst.ident option * FAst.ident = (Some (`Lid (, "g")), `Uid (, "U"))
     </code></pre>
     It should be fixed by introducing more advanced grammar features<br>
</div>
<pre><span id="VALqualuid"><span class="keyword">val</span> qualuid</span> : <code class="type"><a href="FAst.html#TYPEvid">FAst.vid</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><br>
parse qualified  <code class="code">X.Y.g</code>
     <pre class="codepre"><code class="code">     with str t qualid {| A.B.g |};
     - : FAst.ident = `Dot (, `Uid (, "A"), `Dot (, `Uid (, "B"), `Lid (, "g")))
     </code></pre><br>
<pre><span id="VALqualid"><span class="keyword">val</span> qualid</span> : <code class="type"><a href="FAst.html#TYPEvid">FAst.vid</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALt_qualid"><span class="keyword">val</span> t_qualid</span> : <code class="type"><a href="FAst.html#TYPEvid">FAst.vid</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
parse qualified path ending with <code class="code">X.t</code>
     <pre class="codepre"><code class="code">     with str t t_qualid {| A.U.t |};
     - : FAst.ident = `Dot (, `Uid (, "A"), `Uid (, "U"))
     </code></pre><br>
</div>
<pre><span id="VALentry_name"><span class="keyword">val</span> entry_name</span> : <code class="type">([ `name of <a href="FToken.html#TYPEname">FToken.name</a> | `non ] * FGramDef.name) <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALlocals"><span class="keyword">val</span> locals</span> : <code class="type">FGramDef.name list <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><br>
return an entry <code class="code">FGramDef.entry</code>
  <pre class="codepre"><code class="code">with str t entry {| entry:
    [ entry_name{(n,p)}; ":";  OPT position{pos}; level_list{levels}
     -&gt; begin 
     match n with
     |`name old -&gt; AstQuotation.default := old
     | _ -&gt; () ;  
    mk_entry ~name:p ~pos ~levels
    end] |}</code></pre><br>
<pre><span id="VALentry"><span class="keyword">val</span> entry</span> : <code class="type">FGramDef.entry <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALposition"><span class="keyword">val</span> position</span> : <code class="type"><a href="FAst.html#TYPEexp">FAst.exp</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
parse <code class="code">position</code> and translate into <code class="code">exp</code> node, fixme,
    delay the translation<br>
</div>
<pre><span id="VALassoc"><span class="keyword">val</span> assoc</span> : <code class="type"><a href="FAst.html#TYPEexp">FAst.exp</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
parse association, and translate into <code class="code">exp</code> node. FIXME<br>
</div>
<pre><span id="VALname"><span class="keyword">val</span> name</span> : <code class="type">FGramDef.name <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALstring"><span class="keyword">val</span> string</span> : <code class="type"><a href="FAst.html#TYPEexp">FAst.exp</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALsimple_exp"><span class="keyword">val</span> simple_exp</span> : <code class="type"><a href="FAst.html#TYPEexp">FAst.exp</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALdelete_rules"><span class="keyword">val</span> delete_rules</span> : <code class="type"><a href="FAst.html#TYPEexp">FAst.exp</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALpattern"><span class="keyword">val</span> pattern</span> : <code class="type">FGramDef.action_pattern <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALsimple_pat"><span class="keyword">val</span> simple_pat</span> : <code class="type">FGramDef.simple_pat <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALinternal_pat"><span class="keyword">val</span> internal_pat</span> : <code class="type">FGramDef.simple_pat <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALpsymbol"><span class="keyword">val</span> psymbol</span> : <code class="type">FGramDef.symbol <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
return symbol with patterns (may override inferred patterns)<br>
</div>
<pre><span id="VALsymbol"><span class="keyword">val</span> symbol</span> : <code class="type">FGramDef.symbol <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
return symbol with pattern(inferred) or None<br>
</div>
<pre><span id="VALrule"><span class="keyword">val</span> rule</span> : <code class="type">FGramDef.rule <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
return a <code class="code">rule</code>
    <pre class="codepre"><code class="code">with str t rule {|  `Uid ("LA"|"RA"|"NA" as x)   |};
    - : FGramDef.rule =
     {prod =
     [{text =
     `Stok
     (,
     `Fun
     (,
     `Bar
     (,
     `Case
     (,
     `App
     (, `Vrn (, "Uid"),
     `Bar
     (, `Bar (, `Str (, "LA"), `Str (, "RA")), `Str (, "NA"))),
     `Nil , `Id (, `Lid (, "true"))),
     `Case (, `Any , `Nil , `Id (, `Lid (, "false"))))),
     "Normal", "`Uid (\"LA\"|\"RA\"|\"NA\")");
     styp = `Tok ;
     pattern =
     Some
     (`App
     (, `Vrn (, "Uid"),
     `Alias
     (, `Bar (, `Bar (, `Str (, "LA"), `Str (, "RA")), `Str (, "NA")),
     `Lid (, "x"))))}];
     action = None}
     </code></pre><br>
</div>
<pre><span id="VALrule_list"><span class="keyword">val</span> rule_list</span> : <code class="type">FGramDef.rule list <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALlevel"><span class="keyword">val</span> level</span> : <code class="type">FGramDef.level <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALlevel_list"><span class="keyword">val</span> level_list</span> : <code class="type">[ `Group of FGramDef.level list | `Single of FGramDef.level ] <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><pre><span id="VALextend_body"><span class="keyword">val</span> extend_body</span> : <code class="type"><a href="FAst.html#TYPEexp">FAst.exp</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre><div class="info">
the main entrance
     return an already converted expession
     <pre class="codepre"><code class="code">     with str t extend_body  {|
     nonterminalsclear:
     [ qualuid{t}; L0 [a_lident{x}-&gt;x ]{ls} -&gt; ()] |} |&gt; Ast2pt.print_exp f;

     Fgram.extend (nonterminalsclear : 'nonterminalsclear Fgram.t )
     (None,
     [(None, None,
     [([`Snterm (Fgram.obj (qualuid : 'qualuid Fgram.t ));
     `Slist0
     (Fgram.srules nonterminalsclear
     [([`Snterm (Fgram.obj (a_lident : 'a_lident Fgram.t ))],
     (Fgram.mk_action
     (fun (x : 'a_lident)  (_loc : FLoc.t)  -&gt; (x : 'e__7 ))))])],
     (Fgram.mk_action
     (fun (ls : 'e__7 list)  (t : 'qualuid)  (_loc : FLoc.t)  -&gt;
     (() : 'nonterminalsclear ))))])])
     </code></pre>
<p>

     the function <code class="code">text_of_functorial_extend</code> is the driving force
     it has type
     <pre class="codepre"><code class="code"> FAst.loc -&gt;
     FAst.ident option -&gt;
     FGramDef.name list option -&gt; FGramDef.entry list -&gt; FAst.exp
     </code></pre><br>
</div>
<pre><span id="VALdelete_rule_body"><span class="keyword">val</span> delete_rule_body</span> : <code class="type"><a href="FAst.html#TYPEexp">FAst.exp</a> <a href="Fgram.html#TYPEt">Fgram.t</a></code></pre></body></html>