(* internal *)      
(* let mark_used modif tbl n = (\* bool ref -> ('a, used ref * 'b) Hashtbl.t -> 'a -> unit*\) *)
(*   try let rll = Hashtbl.find_all tbl n in *)
(*   List.iter (fun *)
(*     [ (({contents=Unused} as r), _)   ->  begin *)
(*       r := UsedNotScanned; modif := True; *)
(*     end *)
(*     |  _ -> () ]) rll *)
(*   with *)
(*     [ Not_found -> () ] ; *)
    
(* internal *)
(* let  mark_symbol modif tbl symb = *)
(* (\* bool ref -> (string, used ref * 'a) Hashtbl.t -> ('b, 'c) symbol -> unit*\) *)
(*   List.iter (fun e -> mark_used modif tbl e) symb.used ; *)

(* internal
   mainly to report unused local entry. You need to
   feed a name list and entry list to check
 *)  
(* let check_use nl el = (\* 'a name list -> (Ast.expr, 'b) entry list -> unit*\) *)
(*   let tbl = Hashtbl.create 301 in *)
(*   let modif = ref False in *)
(*   let ()=  List.iter (fun e *)
(*     -> let u = match e.name.expr with *)
(*     [ <:expr< $lid:_ >> -> Unused *)
(*     | _ -> UsedNotScanned ] in Hashtbl.add tbl e.name.tvar (ref u, e)) *)
(*       el in  *)
(*   let ()= List.iter (fun n *)
(*     -> try let rll = Hashtbl.find_all tbl n.tvar in *)
(*     List.iter (fun (r, _) -> r := UsedNotScanned) rll *)
(*     with _ -> ())   nl in  *)
(*   let () = modif := True in  *)
(*   let () = *)
(*     while !modif do  *)
(*       modif := False; *)
(*       Hashtbl.iter (fun _ (r, e) -> *)
(*         if !r = UsedNotScanned then begin   *)
(*           r := UsedScanned; *)
(*           List.iter (fun level *)
(*             -> let rules = level.rules in *)
(*             List.iter(fun rule -> *)
(*               List.iter (fun s -> mark_symbol modif tbl s) *)
(*                 rule.prod) *)
(*               rules) *)
(*             e.levels *)
(*         end *)
(*         else ())  tbl *)
(*       done in *)
(*  Hashtbl.iter (fun s (r, e) -> *)
(*    if !r = Unused then *)
(*      print_warning e.name.loc ("Unused local entry \"" ^ s ^ "\"") *)
(*    else ()) tbl; *)
