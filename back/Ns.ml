


(* open LibUtil; *)

(* type key =  list SMap.key; *)
(* type gate 'a = *)
(*     [ Empty *)
(*     | Value a *)
(*     | Gate ]; *)

(* type  t 'a = [ Node of gate 'a and SMap.t ( t 'a) ]; *)

(* type namespace 'a = { *)
(*     data: mutable (t 'a); *)
(*     subs: Hashset.t (t 'a); (\* sub-nodes searchable*\) *)
(*    }; *)

(* let empty = Node (Empty, SMap.empty); *)

(* let rec find (l:key) t = *)
(*   match (l,t) with *)
(*   [ ([], Node (Empty,_))   -> *)
(*   | ([], Node (Gate, _)) -> *)
(*       failwith "no value associated with the path yet" *)
(*   | ([], Node (Value v,_)) -> v *)
(*   | ([x::r], Node (_,m)) -> *)
(*       let try t = SMap.find x m in *)
(*       find r t *)
(*       with [Not_found -> failwith "the path does not exist"]]; *)

(* let rec has_path l t = *)
(*   match (l,t) with *)
(*   [ ([], Node(Empty|Gate,t)) -> `path t *)
(*   | ([], Node(Value v,_)) -> `leaf v *)
(*   | ([x::r], Node(_,m)) -> *)
(*       let t = SMap.find x m in *)
(*       has_path r t *)
(*       with [Not_found -> `miss] ]; *)

(* let add l v t = *)
(*   let rec ins = function *)
(*     [ ([], Node (Empty,m)) -> Node (Value v,m) *)
(*     | ([], Node(Gate,m)) -> failwith "add: the path has been marked as a gate" *)
(*     | ([x::r], Node (v,m)) -> *)
(*         let  t' = try SMap.find x m with Not_found -> empty in *)
(*         let t'' = ins (r,t') in *)
(*         Node(v,SMap.add x t'' m)] in *)
(*   ins (l,t); *)

(* let rec remove_leaf l t = *)
(*   match (l,t) with *)
(*   [ ([], Node (Value v,m)) -> Node (Empty,m) *)
(*   | ([x::r], Node (v,m)) ->  *)
(*       try *)
(*         let t' = remove r (SMap.find x m) in *)
(*         Node (v, if t' = empty then SMap.remove x m else SMap.add x t' m) *)
(*       with [Not_found -> t]]; *)


(* (\* import existing path *\)     *)
(* let import_ns (l:key) x = *)
(*   match has_path l x.data with *)
(*   [ `path v ->   Hashset.add x.subs v *)
(*   | `leaf _ -> failwith "the path is a leaf node" *)
(*   | `miss  -> failwith "there is no such path"];   *)

(* (\* closing existing path *\)     *)
(* let close_ns (l:key) x = *)
(*   match has_path l x.data with *)
(*   [`path v ->  Hashset.remove x.subs v *)
(*   |`leaf _ -> failwith "the path is a leaf node" *)
(*   |`miss  -> failwith "there is no such path"];   *)

(* (\* *)
(*   suppose you already import [a.b.c], *)
(*   then you can not  add [a.b.c] again, since [a.b.c] can not *)
(*   be a leaf. *)
(*   But you can add [a.b] *)
(*  *\)     *)
(* let add_ns (l:key) v x = *)
(*   if Hashset.mem x.subs l then *)
(*     failwith "the path can not be  a leaf" *)
(*   else  *)
(*     x.data <- add l  v x.data; *)
  
(* (\* let search   *\) *)
(* let rec map f = function *)
(*   [ Node (None,m)   -> Node (None, SMap.map (map f) m) *)
(*   | Node (Some v,m) -> Node (Some (f v), SMap.map (map f) m)]; *)

(* let mapi f t =  *)
(*   let rec maprec revp = function *)
(*   [ Node (None,m) ->  *)
(*       Node (None, SMap.mapi (fun x -> maprec [x::revp]) m) *)
(*   | Node (Some v,m) ->  *)
(*       Node (Some (f (List.rev revp) v), SMap.mapi (fun x -> maprec [x::revp]) m)] in *)
(*   maprec [] t; *)

(* let iter f t = *)
(*   let rec traverse revp = function *)
(*     [ Node (None,m) ->  *)
(*         SMap.iter (fun x -> traverse [x::revp]) m *)
(*     | Node (Some v,m) ->  *)
(*         begin f (List.rev revp) v; SMap.iter (fun x t -> traverse [x::revp] t) m end] in *)
(*   traverse [] t; *)

(* let  fold f t acc = *)
(*   let rec traverse revp t acc = match t with *)
(*     [ Node (None,m) ->  *)
(*         SMap.fold (fun x -> traverse [x::revp]) m acc *)
(*     | Node (Some v,m) ->  *)
(*         f (List.rev revp) v (SMap.fold (fun x -> traverse [x::revp]) m acc)] in *)
(*   traverse [] t acc; *)

(* let compare cmp a b = *)
(*   let rec comp a b = match (a,b) with *)
(*     [ (Node (Some _, _), Node (None, _)) -> 1 *)
(*     | (Node (None, _), Node (Some _, _)) -> -1 *)
(*     | (Node (None, m1), Node (None, m2)) -> *)
(*         SMap.compare comp m1 m2 *)
(*     | (Node (Some a, m1), Node (Some b, m2)) -> *)
(*         let c = cmp a b in *)
(*         if c <> 0 then c else SMap.compare comp m1 m2] in *)
(*   comp a b; *)

(* let equal eq a b = *)
(*   let rec comp a b = match (a,b) with *)
(*     [ (Node (None, m1), Node (None, m2)) -> *)
(*         SMap.equal comp m1 m2 *)
(*     | (Node (Some a, m1), Node (Some b, m2)) -> *)
(*         eq a b && SMap.equal comp m1 m2 *)
(*     | _ -> false] in *)
(*   comp a b; *)

(* (\* The base case is rather stupid, but constructable *\) *)
(* let is_empty = function *)
(*   [ Node (None, m1) -> SMap.is_empty m1 *)
(*   | _ -> false]; *)
