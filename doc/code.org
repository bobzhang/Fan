#+STARTUP: overview
#+SEQ_TODO: TODO(T) WAIT(W) | DONE(D!) CANCELED(C@) 
#+COLUMNS: %10ITEM  %10PRIORITY %15TODO %65TAGS

#+OPTIONS: toc:4 ^:{} num:nil creator:nil author:nil
#+OPTIONS: author:nil timestamp:nil d:nil
#+STYLE: <link rel="stylesheet" type="text/css" href="../css/style.css">

* code
** Signature
   - Camlp4Syntax
     It contains sub-modules: /Loc/, /Ast/, /Token/, /Gram/,
     /Quotation/, /AntiquotSyntax/
** Printers

   Signature for printer plugin:
   #+BEGIN_SRC caml
   module Printer (Ast : Ast) = struct
     module type S = sig
       value print_interf : ?input_file:string -> ?output_file:string ->
                            Ast.sig_item -> unit;
       value print_implem : ?input_file:string -> ?output_file:string ->
                            Ast.str_item -> unit;
     end;
   end;
   #+END_SRC
   - DumpCamlp4Ast
     Simple, simple marshalize camlp4ast
   - Null
     Do nothing
   - DumpOCamlpAst
     It makes use of the module =Struct.Camlp4Ast2OCamlAst.Make= to
     dump the binary output of ocamlast.
   - OCaml
     Dump to Ocaml's textual output
   - OCamlr Dump to Ocaml's revised textual output. It depends on the
     module OCaml.




** [[file:~/camlp4/src/FanLexer.mll][Lexer]]

   #+BEGIN_SRC ocaml
       (* To store some context information:
        *   loc       : position of the beginning of a string, quotation and comment
        *   in_comment: are we in a comment?
        *   quotations: shall we lex quotation?
        *               If quotations is false it's a SYMBOL token.
        *   antiquots : shall we lex antiquotations.
        *)
     
     type context =
       { loc        : Loc.t    ;
         in_comment : bool     ;
         quotations : bool     ;
         antiquots  : bool     ;
         lexbuf     : lexbuf   ;
         buffer     : Buffer.t }
     
     let default_context lb =
       { loc        = Loc.ghost ;
         in_comment = false     ;
         quotations = true      ;
         antiquots  = false     ;
         lexbuf     = lb        ;
         buffer     = Buffer.create 256 }
        
   #+END_SRC

   #+BEGIN_SRC ocaml
     val loc:context -> Loc.t
     val set_start_p:context -> unit
     val move_start_p : int -> context -> unit
     val with_curr_loc : (context -> Lexing.lexbuf -> 'a) -> context -> 'a
   #+END_SRC

*** state machine
    #+BEGIN_SRC ocaml
    val token : context -> Lexing.lexbuf -> FanSig.camlp4_token    
    #+END_SRC

**** when it meets '"'
    #+BEGIN_SRC ocaml
      { with_curr_loc string c;
        let s = buff_contents c in STRING (TokenEval.string s, s)}
    #+END_SRC

**** when it meets "'"

     #+BEGIN_SRC ocaml
       | "'" (newline as x) "'"
             { update_loc c None 1 false 1; CHAR (TokenEval.char x, x)               }
       | "'" ( [^ '\\' '\010' '\013']
             | '\\' (['\\' '"' 'n' 't' 'b' 'r' ' ' '\'']
                    |['0'-'9'] ['0'-'9'] ['0'-'9']
                    |'x' hexa_char hexa_char)
               as x) "'"                                { CHAR (TokenEval.char x, x) }
       | "'\\" (_ as c)
               { err (Illegal_escape (String.make 1 c)) (Loc.of_lexbuf lexbuf)         }     
     #+END_SRC

     

**** when it meets "(*"

     #+BEGIN_SRC ocaml
       | "(*"
           { store c; COMMENT(parse_nested comment (in_comment c))                 }
       | "(*)"
           { warn Comment_start (Loc.of_lexbuf lexbuf)                             ;
             parse comment (in_comment c); COMMENT (buff_contents c)               }
       | "*)"
           { warn Comment_not_end (Loc.of_lexbuf lexbuf)                           ;
             move_start_p (-1) c; SYMBOL "*"                                       }
       
     #+END_SRC     
     So we go into the comment state
**** when it meets quotation
     #+BEGIN_SRC ocaml
       | "<<" (quotchar* as beginning)
              { if quotations c
                then (move_start_p (-String.length beginning) c; (* FIX partial application*)
                      mk_quotation quotation c "" "" 2)
                else parse (symbolchar_star ("<<" ^ beginning)) c                       }
       | "<<>>"
           { if quotations c
             then QUOTATION { q_name = ""; q_loc = ""; q_shift = 2; q_contents = "" }
             else parse (symbolchar_star "<<>>") c                                   }
       | "<@"
           { if quotations c then with_curr_loc maybe_quotation_at c
             else parse (symbolchar_star "<@") c                                     }
       | "<:"
           { if quotations c then with_curr_loc maybe_quotation_colon c
             else parse (symbolchar_star "<:") c                                     }
            
     #+END_SRC

     The complexity appears here when we want to handle both
     quotations and noquotations support.

     #+BEGIN_SRC ocaml
       mk_quotation: (context -> Lexing.lexbuf -> unit) ->
         context -> string -> string -> int -> FanSig.camlp4_token     
     #+END_SRC
     #+BEGIN_SRC ocaml
     maybe_quotation_at:context -> Lexing.lexbuf -> FanSig.camlp4_token
     #+END_SRC

**** meets "#"

     #+BEGIN_SRC ocaml
       | "#" [' ' '\t']* (['0'-'9']+ as num) [' ' '\t']*
        ("\"" ([^ '\010' '\013' '"' ] * as name) "\"")?
        [^ '\010' '\013'] * newline
       { let inum = int_of_string num in
         update_loc c name inum true 0; LINE_DIRECTIVE(inum, name) }
     #+END_SRC
     
**** ESCAPEd_INDENT
     #+BEGIN_SRC ocaml
       | '(' (not_star_symbolchar as op) ')'
             { ESCAPED_IDENT (String.make 1 op) }
       | '(' (not_star_symbolchar symbolchar* not_star_symbolchar as op) ')'
             { ESCAPED_IDENT op }
       | '(' (not_star_symbolchar symbolchar* as op) blank+ ')'
                                                              { ESCAPED_IDENT op }
       | '(' blank+ (symbolchar* not_star_symbolchar as op) ')'
                                                            { ESCAPED_IDENT op }
       | '(' blank+ (symbolchar+ as op) blank+ ')'
                                                 { ESCAPED_IDENT op }
            
     #+END_SRC

     
**** symbol
     #+BEGIN_SRC ocaml
       | ( "#"  | "`"  | "'"  | ","  | "."  | ".." | ":"  | "::"
           | ":=" | ":>" | ";"  | ";;" | "_"
           | left_delimitor | right_delimitor ) as x  { SYMBOL x }
       | '$' { if antiquots c
               then with_curr_loc dollar (shift 1 c)
               else parse (symbolchar_star "$") c }
       | ['~' '?' '!' '=' '<' '>' '|' '&' '@' '^' '+' '-' '*' '/' '%' '\\'] symbolchar *
         as x { SYMBOL x }
            
     #+END_SRC
*** utilities
    =store= store current lexeme into  =c.buffer=
    =istore_char= stores ith char in the lexeme into =c.buffer=
    =buffer_contents= return the buffer contents and reset the buffer
    =loc= returns the current location(wider)
    =in_comment= sets the =in_comment= state to true

    =set_start_p= sets the =c.lexbuf.lex_start_p=

    =move_start_p= moves the =start= shift in one line (if not in the
    same line, may be buggy)

    
*** special case
    #+BEGIN_SRC ocaml
      '
      ';;
      - : char = '\n'
      
    #+END_SRC


*** bugs to be fixed

**** quotation
     - comment in quotation
       we require comment quotation is also correct, so there's nothing
       to be fixed here
     - string in quotation
       fixed 
     - newline
       no need to fix


**** antiquotation
     - string in antiquot
     - quot in antiquot


**** cautious
     take care $(m.app) parenthesese is need
     
* ideas
  

** take a look at design of xstrp4
   how to make
   =/fprintf ppf "ghso" more simple /=

   =/<:fmt<Illegal character ($(Char.escaped c))>>/=

   the quotation fmt can config which "fprintf" was used actually,
   like "bprintf", "ifprintf", "eprintf"
** integrating ulex
   an extensible lexer?
