#+STARTUP: overview
#+SEQ_TODO: TODO(T) WAIT(W) | DONE(D!) CANCELED(C@) 
#+COLUMNS: %10ITEM  %10PRIORITY %15TODO %65TAGS

#+OPTIONS: toc:4 ^:{} num:nil creator:nil author:nil
#+OPTIONS: author:nil timestamp:nil d:nil
#+STYLE: <link rel="stylesheet" type="text/css" href="../css/style.css">

* code
** Signature
   - Camlp4Syntax
     It contains sub-modules: /Loc/, /Ast/, /Token/, /Gram/,
     /Quotation/, /AntiquotSyntax/
** Printers

   Signature for printer plugin:
   #+BEGIN_SRC caml
   module Printer (Ast : Ast) = struct
     module type S = sig
       value print_interf : ?input_file:string -> ?output_file:string ->
                            Ast.sig_item -> unit;
       value print_implem : ?input_file:string -> ?output_file:string ->
                            Ast.str_item -> unit;
     end;
   end;
   #+END_SRC
   - DumpCamlp4Ast
     Simple, simple marshalize camlp4ast
   - Null
     Do nothing
   - DumpOCamlpAst
     It makes use of the module =Struct.Camlp4Ast2OCamlAst.Make= to
     dump the binary output of ocamlast.
   - OCaml
     Dump to Ocaml's textual output
   - OCamlr Dump to Ocaml's revised textual output. It depends on the
     module OCaml.




** [[file:~/camlp4/src/FanLexer.mll][Lexer]]

   #+BEGIN_SRC ocaml
       (* To store some context information:
        *   loc       : position of the beginning of a string, quotation and comment
        *   in_comment: are we in a comment?
        *   quotations: shall we lex quotation?
        *               If quotations is false it's a SYMBOL token.
        *   antiquots : shall we lex antiquotations.
        *)
     
     type context =
       { loc        : Loc.t    ;
         in_comment : bool     ;
         quotations : bool     ;
         antiquots  : bool     ;
         lexbuf     : lexbuf   ;
         buffer     : Buffer.t }
     
     let default_context lb =
       { loc        = Loc.ghost ;
         in_comment = false     ;
         quotations = true      ;
         antiquots  = false     ;
         lexbuf     = lb        ;
         buffer     = Buffer.create 256 }
        
   #+END_SRC

   #+BEGIN_SRC ocaml
     val loc:context -> Loc.t
     val set_start_p:context -> unit
     val move_start_p : int -> context -> unit
     val with_curr_loc : (context -> Lexing.lexbuf -> 'a) -> context -> 'a
   #+END_SRC

*** state machine
    #+BEGIN_SRC ocaml
    val token : context -> Lexing.lexbuf -> FanSig.camlp4_token    
    #+END_SRC

**** when it meets '"'
    #+BEGIN_SRC ocaml
      { with_curr_loc string c;
        let s = buff_contents c in STRING (TokenEval.string s, s)}
    #+END_SRC

**** when it meets "'"

     #+BEGIN_SRC ocaml
       | "'" (newline as x) "'"
             { update_loc c None 1 false 1; CHAR (TokenEval.char x, x)               }
       | "'" ( [^ '\\' '\010' '\013']
             | '\\' (['\\' '"' 'n' 't' 'b' 'r' ' ' '\'']
                    |['0'-'9'] ['0'-'9'] ['0'-'9']
                    |'x' hexa_char hexa_char)
               as x) "'"                                { CHAR (TokenEval.char x, x) }
       | "'\\" (_ as c)
               { err (Illegal_escape (String.make 1 c)) (Loc.of_lexbuf lexbuf)         }     
     #+END_SRC

     

**** when it meets "(*"

     #+BEGIN_SRC ocaml
       | "(*"
           { store c; COMMENT(parse_nested comment (in_comment c))                 }
       | "(*)"
           { warn Comment_start (Loc.of_lexbuf lexbuf)                             ;
             parse comment (in_comment c); COMMENT (buff_contents c)               }
       | "*)"
           { warn Comment_not_end (Loc.of_lexbuf lexbuf)                           ;
             move_start_p (-1) c; SYMBOL "*"                                       }
       
     #+END_SRC     
     So we go into the comment state
**** when it meets quotation
     #+BEGIN_SRC ocaml
       | "<<" (quotchar* as beginning)
              { if quotations c
                then (move_start_p (-String.length beginning) c; (* FIX partial application*)
                      mk_quotation quotation c "" "" 2)
                else parse (symbolchar_star ("<<" ^ beginning)) c                       }
       | "<<>>"
           { if quotations c
             then QUOTATION { q_name = ""; q_loc = ""; q_shift = 2; q_contents = "" }
             else parse (symbolchar_star "<<>>") c                                   }
       | "<@"
           { if quotations c then with_curr_loc maybe_quotation_at c
             else parse (symbolchar_star "<@") c                                     }
       | "<:"
           { if quotations c then with_curr_loc maybe_quotation_colon c
             else parse (symbolchar_star "<:") c                                     }
            
     #+END_SRC

     The complexity appears here when we want to handle both
     quotations and noquotations support.

     #+BEGIN_SRC ocaml
       mk_quotation: (context -> Lexing.lexbuf -> unit) ->
         context -> string -> string -> int -> FanSig.camlp4_token     
     #+END_SRC
     #+BEGIN_SRC ocaml
     maybe_quotation_at:context -> Lexing.lexbuf -> FanSig.camlp4_token
     #+END_SRC

**** meets "#"

     #+BEGIN_SRC ocaml
       | "#" [' ' '\t']* (['0'-'9']+ as num) [' ' '\t']*
        ("\"" ([^ '\010' '\013' '"' ] * as name) "\"")?
        [^ '\010' '\013'] * newline
       { let inum = int_of_string num in
         update_loc c name inum true 0; LINE_DIRECTIVE(inum, name) }
     #+END_SRC
     
**** ESCAPEd_INDENT
     #+BEGIN_SRC ocaml
       | '(' (not_star_symbolchar as op) ')'
             { ESCAPED_IDENT (String.make 1 op) }
       | '(' (not_star_symbolchar symbolchar* not_star_symbolchar as op) ')'
             { ESCAPED_IDENT op }
       | '(' (not_star_symbolchar symbolchar* as op) blank+ ')'
                                                              { ESCAPED_IDENT op }
       | '(' blank+ (symbolchar* not_star_symbolchar as op) ')'
                                                            { ESCAPED_IDENT op }
       | '(' blank+ (symbolchar+ as op) blank+ ')'
                                                 { ESCAPED_IDENT op }
            
     #+END_SRC

     
**** symbol
     #+BEGIN_SRC ocaml
       | ( "#"  | "`"  | "'"  | ","  | "."  | ".." | ":"  | "::"
           | ":=" | ":>" | ";"  | ";;" | "_"
           | left_delimitor | right_delimitor ) as x  { SYMBOL x }
       | '$' { if antiquots c
               then with_curr_loc dollar (shift 1 c)
               else parse (symbolchar_star "$") c }
       | ['~' '?' '!' '=' '<' '>' '|' '&' '@' '^' '+' '-' '*' '/' '%' '\\'] symbolchar *
         as x { SYMBOL x }
            
     #+END_SRC
*** utilities
    =store= store current lexeme into  =c.buffer=
    =istore_char= stores ith char in the lexeme into =c.buffer=
    =buffer_contents= return the buffer contents and reset the buffer
    =loc= returns the current location(wider)
    =in_comment= sets the =in_comment= state to true

    =set_start_p= sets the =c.lexbuf.lex_start_p=

    =move_start_p= moves the =start= shift in one line (if not in the
    same line, may be buggy)

    
*** special case
    #+BEGIN_SRC ocaml
      '
      ';;
      - : char = '\n'
      
    #+END_SRC



*** bugs to be fixed

**** quotation
     - comment in quotation
       we require comment quotation is also correct, so there's nothing
       to be fixed here
     - string in quotation
       fixed 
     - newline
       no need to fix


**** antiquotation
     - string in antiquot
     - quot in antiquot


**** cautious
     take care $(m.app) parenthesese is need
** Gramar

   #+BEGIN_SRC ocaml
     module type Action = sig
         type t
         val  mk: 'a -> t
         val get: t -> 'a
         val getf: t -> ('a->'b)
         val getf2: t -> ('a->'b->'c)
       end
     type assoc = NonA | LeftA | RightA
     type position =
         First
       | Last
       | Before of string
       | After of string
       | Level of string
     
     module type Structure =  sig
         module Loc: FanSig.Loc
         module Action:Action
         module Token: FanSig.Token with module Loc = Loc
     
         (* more like global information related to lexer *)                                               
         type gram = {
           gfilter: Token>Filter.t;
           gkeywords: Hashtbl.t string (ref int);
           glexer: Loc.t -> Stream.t char -> Stream.t (Token.t * Loc.t);
           waring_verbose: ref bool;
           error_verbose: ref bool;
         }
         type efun = token_stream -> Action.t
         type token_pattern = ((Token.t -> bool) * string)
                                
         type internal_array ={
           egram: gram;
           ename: string;
           mutable estart: int -> efun ;
           mutable econtinue: int -> Loc.t -> Action.t -> efun;
           mutable edesc: desc }
         and desc =
            Dlevels of list level
            | Dparser of token_stream -> Action.t
         and level = {
           assoc: assoc;
           lname: string option;
           lsuffix: tree;
           lprefix: tree
         }
         and symbol = 
             Smeta of string * list symbol * Action.t (* Action.t *)
           | Snterm of internal_entry (* internal_array *)
           | Snterml of internal_entry * string
           | Slist0 of symbol
           | Slist0sep of symbol * symbol
           | Slist1 of symbol
           | Slist1sep of symbol * symbol
           | Sopt of symbol
           | Stry of symbol
           | Sself of symbol
           | Snext
           | Stoken of token_pattern (* a function *)
           | Skeyword of string
           | Stree of tree
         and tree =
           Node of node
           | LocAct of Action.t * Action.t list
           | DeadEnd
         and node  ={
           node: symbol;
           son: tree;
           brother: tree
         }
         type token_info = {
           prev_loc: Loc.t;
           cur_loc: Loc.t;
           prev_loc_only: bool;
         }
         type production_rule = (list symbol * Action.t )
         type signle_extend_statement =
             (string option * assoc option * production_rule list )
         type extend_statement = (position option * single_extend_statement list)
         type delete_statement = list symbol
                             
         type token_stream = Stream.t (Token.t * token_info)
         val token_location: token_info -> Loc.t
     
         type fold 'a 'b 'c =
             internal_entry -> symbol list -> ('a Stream.t -> 'b) ->  'a Stream.t -> 'c
         type foldsep 'a 'b 'c =
             internal_entry -> symbol list -> ('a Stream.t -> 'b) -> ('a Stream.t -> unit) -> 'a Stream.t -> 'c
       end
     
     (* Dynamic means that you can produce as many grammar values as needed with a signle grammar module
        If you do not need many grammar values it's preferable to use a static one
      *)                           
     module type  Dynamic = sig
         include Structure
         val mk: unit -> gram
         module Entry : sig
           type 'a t
           val mk : gram -> string -> 'a t
           val of_parser: gram -> string -> (token_stream -> 'a ) -> 'a t
     
           (* clear the entry and setup this parser instead *)                                                                   
           val setup_parser:
             'a t -> (token_stream -> 'a) -> unit
           val name: 'a t -> string
           val print: Format.formatter -> 'a t -> unit
     
           (* same as {!print} but shows the left factorization
                {[
                 Gram.Entry.dump std_formatter Syntax.expr
                ]}
            *)                                         
           val dump: Format.formatter -> 'a t -> unit
           val obj: 'a t -> internal_entry
           val clear: 'a t -> unit
         end
         val get_filter: gram -> Token.Filter.t
         type not_filtered 'a
     
         val extend: 'a Entry.t -> extend_statement -> unit
         val delete_rule: 'a Entry.t -> delete_statement -> unit
         val srules: 'a Entry.t -> (symbol list * Action.t) list -> symbol
         val sfold0: ('a->'b ->'b) -> 'b -> fold _ 'a 'b
         val sfold1: ('a->'b -> 'b) -> 'b -> fold _ 'a 'b
         val sfold0sep: ('a -> 'b -> 'b) -> 'b -> foldsep _ 'a 'b
     
         (* use the lexer to produce  a non filtered token stream from a char stream  *)                                                     
         val lex: gram -> Loc.t -> char Stream.t -> ((Token.t * Loc.t) Stream.t) not_filtered 
         val lex_string: gram - Loc.t -> string -> ((Token.t * Loc.t) Stream.t) not_filtered 
                                                                
         val filter: gram -> not_filtered ((Token.t * Loc.t)Stream.t)  -> token_stream
     
         val parse: 'a Entry.t -> Loc.t -> char Stream.t -> 'a
         val parse_string: 'a Entry.t -> Loc.t -> string -> 'a
     
         val parse_tokens_before_filter: 'a Entry.t -> not_filtered ((Token.t*Loc.t) Stream.t) -> 'a
         val parse_tokens_after_filter: 'a Entry.t -> token_stream -> 'a
       end
     
     
     (* There's only one grammar value by grammar module *)                         
     module type Static = sig
         include Structure
         val trace_parser: ref bool
         val gram: gram;
         module Entry : sig
           type 'a t
           val mk:string -> t 'a
           val of_parser:
             string -> (token_stream -> 'a) -> 'a t
           val setup_parser: 'a t -> (token_stream ->'a) -> unit
           val name: 'a t -> string
           val print: Format.formatter -> 'a t -> unit
           val dump: Format.formatter -> 'a t -> unit
           val obj: 'a t -> internal_entry
           val clear: 'a t -> unit
         end
         val get_filter: unit -> Token.Filter.t
         type 'a not_filtered
         val extend: 'a Entry.t -> extend_statement -> unit
         val delete_rule: 'a Entry.t -> delete_statement -> unit
         val srules: 'a Entry.t -> (symbol list * Action.t) list -> symbol
         val sfold0: ('a->'b ->'b) -> 'b -> fold _ 'a 'b
         val sfold1: ('a->'b -> 'b) -> 'b -> fold _ 'a 'b
         val sfold0sep: ('a -> 'b -> 'b) -> 'b -> foldsep _ 'a 'b
     
         (* use the lexer to produce  a non filtered token stream from a char stream  *)                                                     
         val lex: gram -> Loc.t -> char Stream.t -> ((Token.t * Loc.t) Stream.t) not_filtered 
         val lex_string: gram - Loc.t -> string -> ((Token.t * Loc.t) Stream.t) not_filtered 
                                                                
         val filter: gram -> not_filtered ((Token.t * Loc.t)Stream.t)  -> token_stream
     
         val parse: 'a Entry.t -> Loc.t -> char Stream.t -> 'a
         val parse_string: 'a Entry.t -> Loc.t -> string -> 'a
     
         val parse_tokens_before_filter: 'a Entry.t -> not_filtered ((Token.t*Loc.t) Stream.t) -> 'a
         val parse_tokens_after_filter: 'a Entry.t -> token_stream -> 'a
       end
   #+END_SRC

**** grammar

     #+BEGIN_SRC ocaml
       expr: AFTER "top"
         [ [ "EXTEND"; e = extend_body; "END" -> e
           | "DELETE_RULE"; e = delete_rule_body; "END" -> e ]];
       
       extend_body:
         [ [ (gram,g) = extend_header; global_list=OPT global;
             el = LIST1 [e=entry; semi_sep -> e] ->
                  text_of_functorial_extend _loc g gram global_list el ]];
       (*[text_of_functorial_extend: Ast.loc -> Ast.ident -> Ast.ident option ->
          Ast.expr name list option -> (Ast.expr, Ast.patt) entry list -> Ast.expr ]
         it emits a subcall [text_of_entry], pos is pattern, txt is the action
         [let_in_of_extend]
         [gm] is [Camlp4Grammar__]
         One is for module [Dynamic], the other is for the module [Static]
       
         [srules]
         [make_expr_rules]
        *)
       extend_header:
         [ [ "("; i= qualid; ":"; t = t_qualid; ")" -> (Some i,t)
           | g = qualuid -> (None,g) (* Gram *) ]];
          (* return either [(None,Gram)] or [(Some g, Gram.t)]*)
       
       qualuid:
         [ [ x = UIDENT ; "."; xs = SELF -> <:ident< $uid:x.$xs >>
           | i = UIDENT -> <:ident< $uid:i >> ]];
       
       qualid:
         [ [  x = UIDENT; "."; xs = SELF  -> <:ident< $uid:x.$xs >>
           |  i = UIDENT -> <:ident< $uid:i >>
           |  u = LIDENT -> <:ident< $lid:i >> ]];
       t_qualid:
         [ [ x = UIDENT; "."; xs = SELF -> <:ident< $uid:x.$xs >>
           | x = UIDENT; "."; `LIDENT "t" -> <:ident< $uid:x >>
           | `(LIDENT _ | UIDENT _ ) ->
              Loc.raise
                _loc
                (Stream.Error
                   "Wrong EXTEND header, the grammar type must finish by 't' \
                    like in EXTEND (g:Gram.t) ... END "
                             )
         ]];
       global:
         [ [ UIDENT "GLOBAL"; ":"; sl = LIST1 name; semi_sep -> sl ]];
       
       name:
         [ [ il = qualid -> mk_name _loc il ]];
       
       entry:
         [ [ n = name; ":"; pos = OPT position; ll = level_list -> (* "entry" here is the name *)
            {name=n;pos=pos; levels = ll} (* (Ast.expr,Ast.patt) entry entry was defined locally*)
                                         
         ]];
       position:
         [ [ UIDENT "FIRST"  -> <:expr< Camlp4.Sig.Grammar.First >>
           | UIDENT "LAST"   -> <:expr< Camlp4.Sig.Grammar.Last >>
           | UIDENT "BEFORE"; n = string -> <:expr< Camlp4.Sig.Grammar.Before $n >>
           | UIDENT "AFTER";  n = string -> <:expr< Camlp4.Sig.Grammar.After $n >>
           | UIDENT "LEVEL";  n = string -> <:expr< Camlp4.Sig.Grammar.Level $n >> 
         ]];
       level_list:
         [ [ "["; ll = LIST0 level SEP "|"; "]" -> ll ]];
       
       level:
         [ [ lab = OPT [ x = STRING -> x ]; ass = OPT assoc; rules = rule_list ->
             {label = lab; assoc = ass; rules = rules} (* (Ast.expr, Ast.patt) level *) ]];
       assoc:
         [ [ UIDENT "LEFTA" -> <:expr< Camlp4.Sig.Grammar.LeftA >>
           | UIDENT "RIGHTA" -> <:expr< Camlp4.Sig.Grammar.RightA >>
           | UIDENT "NONA"  -> <:expr< Camlp4.Sig.Grammar.NonA >>
         ] ];
       
       rule_list:
         [ ["["; "]" -> []
           | "["; rules = LIST1 rule SEP "|"; "]" ->
              retype_rule_list_without_patterns _loc rules
         ]];
       
       rule:
         [ [ ps1 = LIST0 psymbol SEP semi_sep; "->"; act = expr ->
             {prod = psl; action = Some act }
           | psl = LIST0 psymbol SEP semi_sep -> (* none action allowed actually *)
             {prod = psl; action = None} (* (Ast.expr,Ast.patt) rule *)
         ]];
       
       psymbol:
         [ [ p = LIDENT; "=" s = symbol ->
             match s.pattern with
             [ Some (<:patt<  $uid:u $(tup:<:patt< _ >> ) >>  as p') ->
               let match_fun = <:expr< fun [ $pat:p' -> True | _ -> False ] >> in
               let p' = <:patt< ($p' as $lid:p) >> in
               let descr = u ^ "_" in
               let text = TXtok _loc match_fun descr in
               { (s) with pattern =  Some <:patt< $lid:p >> }
             | i = LIDENT; lev = OPT [UIDENT "LEVEL"; s = STRING -> s] ->
                let name = mk_name _loc <:ident< $lid:i >> in
                let text = TXnterm _loc name lev in
                let styp = STquo _loc i in
                {used=[i]; text =text; styp=styp; pattern = None }
             | p = pattern; "="; s = symbol ->
                match s.pattern with
                [ Some <:patt< $uid:u $(tup: <:patt< _ >> ) >> ->
                  mk_tok _loc <:patt< $uid:u $p >> s.styp
                | _ -> { (s) with pattern = Some p }]
             | s = symbol -> s
             ]
         ]];
       
       symbol
         [ "top" NONA
            [UIDENT "LIST0"; s = SELF ; sep = OPT [UIDENT "SEP"; t = symbol -> t] ->
             let () = check_not_tok s in
             let used = match sep with
                 [ Some symb -> symb.used @ s.used
                 | None -> s.used] in
             let styp = STapp _loc (STlid _loc "list") s.styp in
             let text = slist _loc False sep s in 
             {used=s.used; text = text; styp=s.styp; pattern = None}
            | UIDENT "LIST1"; s=SELF; sep = OPT [UIDENT "SEP"; t=symbol -> t] ->
               let () = check_not_tok s in
               let used = match sep with
                   [ Some symb -> symb.used @ s.used
                   | None -> s.used ] in
               let styp = STapp _loc (STlid _loc "list") s.styp in
               let text = slist _loc True sep in
               {used=s.used; text = text; styp=s.styp; pattern = None}
            | UIDENT "TRY"; s = SELF ->
               let text = TXtry _loc s.text in
               {used=s.used; text = text; styp=s.styp; pattern = None} ]
            
          | [  UIDENT "SELF" ->
               {used=[]; text = TXnext _loc; styp = STself _loc "SELF"; pattern = None }
            |  UIDENT "NEXT" ->
               {used= []; text = TXnext _loc; styp = STself _loc "NEXT"; pattern = None}
       
            | "[";  r1 = LIST0 rule SEP "|"; "]" ->
               let r1 = retype_rule_list_without_patterns _loc r1 in
               let t = new_type_var () in
               {used = used_of_rule_list rl;
                text = TXrules _loc (srules _loc t rl "");
                styp = STquo _loc t;
                pattern = None
               }
       
            | "`"; p=patt -> mk_tok _loc p (STtok _loc)
       
            | x = UIDENT -> mk_tok _loc <:patt< $uid:x $(tup:<:patt< _ >> ) >>
            | x = UIDENT; s=STRING -> mk_tok _loc <:patt< $uid:x $str:x >> (STtok _loc)
       
            (* A $v *)                                                                 
            | x = UIDENT; `ANTIQUOT "" s ->
               let e = AntiquotSyntax.parse_expr _loc s in
               let match_fun = <:expr< fun [$uid:x camlp4_x when camlp4_x = $e -> True | _ -> False ] >> in
               let descr = "$" ^ x ^ " " ^ s in
               let text = TXtok _loc match_fun descr in
               let p = <:patt< $uid:x $(tup:<:patt< _ >> ) in
               {used=[]; text=text;styp=STtok _loc; pattern=Some p}
            | s = STRING -> { used=[]; text= TXkwd _loc s ; styp= STtok _loc ; pattern = None }
            | i = UIDENT; "."; il = qualid ;  lev = OPT [UIDENT "LEVEL"; s=STRING -> s] ->
               let n = mk_name _loc <:ident< $uid:i.$il >> in
               {used=[n.tvar]; text = TXnterm _loc n lev; styp = STquo _loc n.tvar; pattern = None }
                 
            | n = name; lev = OPT [UIDENT "LEVEL"; s=STRING -> s] ->
               {used = [n.tvar]; text = TXnterm _loc n lev; styp = STquo _loc n.tvar; pattern  = None}
       
            | "("; s_t = SELF; ")" -> s_t ]
            ];  (* symbol is the key to understand *)
       
       pattern:
         [ [ i=LIDENT -> <:patt< $lid:i >>
           | "_" -> <:patt< _ >>
           | "("; p=pattern; ")" -> <:patt< $p >>
           | "("; p1=pattern; ","; p2= comma_patt; ")" -> <:patt< ($p1,$p2) >>                                
           | p = pattern -> p ]];
       
       comma_patt:
         [ [ p1=SELF; ","; p2=SELF -> <:patt< $p1,$p2 >>
           | p = pattern -> p 
         ]];
       
       name:
         [[ il = qualid -> mk_name _loc il ]];
       
       string:
         [[ s = STRING -> <:expr< $str:s >>
          | `ANTIQUOT "" s -> AntiquotSyntax.parse_expr _loc s ]];
       
       semi_sep:
         [[ ";" -> ()]];
     #+END_SRC
**** grammar code
     
***** [[file:~/camlp4/src/Grammar/Structure.ml][Structure]]
      Type definitions

      #+BEGIN_SRC ocaml
        val using: gram -> string -> unit (* the second argument is
        kwd*)
        val removing: gram -> string -> unit
      #+END_SRC
      
      let's take a look at the definition of =symbol=
****** symbol
       #+BEGIN_SRC ocaml
         and symbol =
           | Smeta of string * symbol list * Action.t (* FOLD0 and FOLD1 *)
           | Snterm of internal_entry (* non-terminal *)
           | Snterml of internal_entry * string (* non-terminal at given level *)
           | Slist0 of symbol (* LIST0 *)
           | Slist0sep of symbol * symbol (* LIST0 SEP *)
           | Slist1 of symbol
           | Slist1 of symbol * symbol
           | Sopt of symbol
           | Stry of symbol
           | Sself
           | Snext
           | Stoken of token_pattern (* representation of a token pattern *)
           | Skeyword of string
           | Stree of tree
         (*did not see it in grammar, the representation of an anonymous rule list *)
                          
         and tree =
           | Node of node
           | LocAct of Action.t * Action.t list
           | DeadEnd
         and node = {
           node: symbol;
           son: tree;
           brother: tree;
         }
         and token_pattern = ((Token.t -> bool) * string)
         
         
         (* mark it as global, so you don't need to create it once again
          *)                      
         (*
         
         Stoken for LIDENT or UIDENT or STRING
         ((Gram.Stoken
            (( function | LIDENT ("debug") -> (true) | _ -> (false)),
          "LIDENT (\"debug\")")) )
         
         (Gram.Stoken
           (( function | STRING (_) -> (true) | _ -> (false) ),
                                  "STRING _"))
          *)
                               
         (* Gram.Entry.obj : 'a t -> string *)
         
         
         (*
         
             end_or_in:
             [ [ "end" -> None
               | "in"; e = expr -> Some e
             ] ];
         
         ==> 
         (
                    (Gram.extend ( (end_or_in : 'end_or_in Gram.Entry.t) ) (
                      ((fun ()
                          ->
                         (None , (
                          [(None , None , (
                            [((
                              [( (Gram.Skeyword ("in")) ); (
                               (Gram.Snterm
                                 (Gram.Entry.obj ( (expr : 'expr Gram.Entry.t) ))) )]
                              ), (
                              (Gram.Action.mk (
                                fun (e :
                                  'expr) ->
                                 fun _ ->
                                  fun (_loc : Gram.Loc.t) -> ((Some (e)) : 'end_or_in)
                                )) ));
                             (( [( (Gram.Skeyword ("end")) )] ), (
                              (Gram.Action.mk (
                                fun _ ->
                                 fun (_loc : Gram.Loc.t) -> ((None) : 'end_or_in) ))
                              ))] ))] ))) () ) ))
                    )
          *)
         (*
             start_debug:
             [ [ LIDENT "debug" -> None
               | LIDENT "camlp4_debug" -> Some "Camlp4"
             ] ];
         ===========>
         (Gram.extend ( (start_debug : 'start_debug Gram.Entry.t) ) (
                      ((fun ()
                          ->
                         (None , (
                          [(None , None , (
                            [((
                              [(
                               (Gram.Stoken
                                 ((
                                  function
                                  | LIDENT ("camlp4_debug") -> (true)
                                  | _ -> (false) ), "LIDENT (\"camlp4_debug\")")) )]
                              ), (
                              (Gram.Action.mk (
                                fun (__camlp4_0 :
                                  Gram.Token.t) ->
                                 fun (_loc :
                                   Gram.Loc.t) ->
                                  (match __camlp4_0 with
                                   | LIDENT ("camlp4_debug") ->
                                      ((Some ("Camlp4")) : 'start_debug)
                                   | _ -> assert false) )) ));
                             ((
                              [(
                               (Gram.Stoken
                                 ((
                                  function | LIDENT ("debug") -> (true) | _ -> (false)
                                  ), "LIDENT (\"debug\")")) )] ), (
                              (Gram.Action.mk (
                                fun (__camlp4_0 :
                                  Gram.Token.t) ->
                                 fun (_loc :
                                   Gram.Loc.t) ->
                                  (match __camlp4_0 with
                                   | LIDENT ("debug") -> ((None) : 'start_debug)
                                   | _ -> assert false) )) ))] ))] ))) () ) ))
          *)                      
       #+END_SRC

****** token_info
       #+BEGIN_SRC ocaml
         type token_info = {
           prev_loc: Loc.t;
           cur_loc: Loc.t;
           prev_loc_only: bool
         }
       #+END_SRC
***** [[file:~/camlp4/src/Grammar/Tools.ml][Tools]]
      Utilities on top of =Structure.S=

      #+BEGIN_SRC ocaml
        val get_prev_loc_only : bool ref
        module Make :
          functor (Structure : Structure.S) ->
            sig
              val empty_entry : string -> 'a -> 'b
              val stream_map :
                ('a -> 'b) -> 'a Stream.t
                -> 'b Stream.t (* utility should be removed *)
        
              val keep_prev_loc :
                ('a * Loc.t) Stream.t ->
                ('a * token_info) Stream.t
              (* transform a stream to another stream with [prev_loc]
                kept *)

              val drop_prev_loc :
                ('a * Structure.token_info) Stream.t ->
                ('a * Structure.Loc.t) Stream.t
              (* drop previous location information *)
              val get_cur_loc :
                ('a * token_info) Stream.t -> Loc.t
              val get_prev_loc :
                ('a * Structure.token_info) Stream.t -> Structure.Loc.t
              val is_level_labelled : string ->level -> bool
              val warning_verbose : bool ref
              val get_token_list :
                'a ->
                symbol list ->
                symbol ->
                tree ->
                (symbol list * symbol * tree) option
              val is_antiquot : string -> bool
              (* s.[0]='$'*)
              val eq_Stoken_ids : string -> string -> bool
              (* none antiquot and equal  *)                                          
              val logically_eq_symbols :
                internal_entry ->
                symbol -> symbol -> bool
              (* *)                        
              val eq_symbol : symbol -> symbol -> bool
            end
      #+END_SRC
      

***** [[file:~/camlp4/src/Grammar/Print.ml][Print]]

****** Make
      #+BEGIN_SRC ocaml
        val flatten_tree : tree -> symbol list list
        val print_symbol : formatter -> symbol -> unit
        val print_meta : formatter -> string -> symbol list -> unit
        val print_symbol1 : formatter -> symbol -> unit
        val print_rule : formatter -> symbol list -> unit
        val print_level : formatter ->
                          (formatter -> unit -> unit) ->
                          symbol list list -> unit
        val levels : formatter -> level list -> unit
        val entry : formatter -> internal_entry -> unit
        
      #+END_SRC
       

****** MakeDump

       #+BEGIN_SRC ocaml
         type brothers = Bro of Structure.symbol * brothers list
         val print_tree :formatter ->tree -> unit
         val print_symbol :formatter ->symbol -> unit
         val print_meta :
          formatter -> string ->symbol list -> unit
         val print_symbol1 :formatter ->symbol -> unit
         val print_rule :formatter ->symbol list -> unit
         val print_level :
          formatter ->
           (formatter -> unit -> unit) ->
          symbol list list -> unit
         val levels :formatter ->level list -> unit
         val entry :formatter ->internal_entry -> unit
                
       #+END_SRC

***** [[file:~/camlp4/src/Grammar/Entry.ml][Entry]]

      #+BEGIN_SRC ocaml
        type 'a t = internal_entry
        (* phantom type *)              
        val name : internal_entry -> string
        val print : formatter -> internal_entry -> unit
        val dump : formatter -> internal_entry -> unit
        val trace_parser : bool ref
        val mk : gram -> string -> internal_entry
        val action_parse : internal_entry -> token_stream -> Action.t
        val lex : internal_entry -> Loc.t ->
                  char Stream.t -> (Token.t * Loc.t) Stream.t
        val lex_string : internal_entry -> Loc.t ->
                         string -> (Token.t * Loc.t) Stream.t
        val filter : internal_entry -> (Token.t * Token.Loc.t) Stream.t ->
                     (Token.t * token_info) Stream.t
        val parse_tokens_after_filter :
          internal_entry -> token_stream -> 'a
        val parse_tokens_before_filter :
          internal_entry ->
          (Token.t * Token.Loc.t) Stream.t -> 'a
        val parse :
          internal_entry -> Loc.t -> char Stream.t -> 'a
        val parse_string :
          internal_entry -> Loc.t -> string -> 'a
        val of_parser :  gram ->  string ->
                         ((Token.t * token_info) Stream.t -> 'a) -> 'a t
        val setup_parser :
          internal_entry ->
          ((Token.t * token_info) Stream.t -> 'a) -> unit
        val clear : internal_entry -> unit
        val obj : 'a -> 'a
              
      #+END_SRC
      
***** [[file:~/camlp4/src/Grammar/Search.ml][Search]]

      #+BEGIN_SRC ocaml
        val tree_in_entry: symbol -> tree -> desc -> tree      
      #+END_SRC
      
***** [[file:~/camlp4/src/Grammar/Failed.ml][Failed]]

      #+BEGIN_SRC ocaml
        val name_of_symbol :
          internal_entry -> symbol -> string
        val name_of_symbol_failed :
          internal_entry -> symbol -> string
        val name_of_tree_failed :
          internal_entry -> tree -> string
        val magic : 'a -> 'b -> 'c
        val tree_failed :
          internal_entry ->
          'a -> symbol -> tree -> string
        val symb_failed :
          internal_entry ->
          'a -> symbol -> symbol -> string
        val symb_failed_txt :
          internal_entry ->
          symbol -> symbol -> string
      #+END_SRC
      
***** [[file:~/camlp4/src/Grammar/Parser.ml][Parser]]

      #+BEGIN_SRC ocaml
        val add_loc: Loc.t -> (token_stream -> 'b) -> token_stream -> 'b * Loc.t
        val level_number: internal_entry -> string -> int
        val strict_parsing: bool ref
        val strict_parsing_warning: bool ref
        val top_symb: internal_entry -> symbol -> symbol
        val top_tree: internal_entry -> tree -> tree
        val entry_of_symb: internal_entry -> symbol -> internal_entry
        val continue: internal_entry -> Loc.t -> Action.t -> symbol -> tree -> efun -> efun
        val do_recover:
          (internal_entry -> 'a -> 'b -> tree -> efun ) ->
          internal_entry -> 'a -> 'b -> Loc.t -> Action.t -> symbol -> tree -> efun
        val recover:
          (internal_entry -> 'a -> 'b -> tree -> efun ) -> internal_entry -> 'a -> 'b ->
          Loc.t -> Action.t -> symbol -> tree -> efun
        val parser_of_tree :
          internal_entry ->
          int -> int -> tree -> Structure.efun
        val parser_cont :
          efun -> internal_entry ->  int -> int ->
          symbol ->tree -> Loc.t -> Action.t -> efun
        val parser_of_token_list :
          (Loc.t -> Action.t -> efun) ->
          symbol list -> efun
        val parser_of_symbol :
          internal_entry ->  int -> symbol -> efun
        val parse_top_symb :
          internal_entry -> symbol -> efun
        val start_parser_of_levels :
          internal_entry ->
          int -> level list -> int -> efun
        
        val start_parser_of_entry :
          internal_entry -> int -> efun
        val continue_parser_of_levels :
          internal_entry -> int -> level list ->
          int -> Loc.t -> 'a -> efun
        val continue_parser_of_entry :
          internal_entry -> int -> Loc.t -> Action.t -> efun
      #+END_SRC

***** [[file:~/camlp4/src/Grammar/Insert.ml][Insert]]

      #+BEGIN_SRC ocaml
        val is_before : Structure.symbol -> Structure.symbol -> bool
        val derive_eps : Structure.symbol -> bool
        val tree_derive_eps : Structure.tree -> bool
        val empty_lev :
          string option -> FanSig.Grammar.assoc option -> Structure.level
        val change_lev :
          Structure.internal_entry ->
          Structure.level ->
          string ->
          string option -> FanSig.Grammar.assoc option -> Structure.level
        val change_to_self :
          Structure.internal_entry -> Structure.symbol -> Structure.symbol
        val get_level :
          Structure.internal_entry ->
          FanSig.Grammar.position option ->
          Structure.level list ->
          Structure.level list *
            (string option -> FanSig.Grammar.assoc option -> Structure.level) *
              Structure.level list
        val check_gram : Structure.internal_entry -> Structure.symbol -> unit
        val tree_check_gram :
          Structure.internal_entry -> Structure.tree -> unit
        val get_initial : Structure.symbol list -> bool * Structure.symbol list
        val insert_tokens : Structure.gram -> Structure.symbol list -> unit
        val insert_tree :
          Structure.internal_entry ->
          Structure.symbol list ->
          Structure.Action.t -> Structure.tree -> Structure.tree
        val insert_level :
          Structure.internal_entry ->
          bool ->
          Structure.symbol list ->
          Structure.Action.t -> Structure.level -> Structure.level
        val levels_of_rules :
          Structure.internal_entry ->
          FanSig.Grammar.position option ->
          (string option * FanSig.Grammar.assoc option *
             (Structure.symbol list * Structure.Action.t) list)
            list -> Structure.level list
        val extend :
          Structure.internal_entry ->
          FanSig.Grammar.position option *
            (string option * FanSig.Grammar.assoc option *
               (Structure.symbol list * Structure.Action.t) list)
                list -> unit
              
      #+END_SRC

***** [[file:~/camlp4/src/Grammar/Fold.ml][Fold]]

      #+BEGIN_SRC ocaml
        value sfold0 : ('a -> 'b -> 'b) -> 'b -> fold _ 'a 'b;
        value sfold1 : ('a -> 'b -> 'b) -> 'b -> fold _ 'a 'b;
        value sfold0sep : ('a -> 'b -> 'b) -> 'b -> foldsep _ 'a 'b;
      #+END_SRC
      
***** [[file:~/camlp4/src/Grammar/Delete.ml][Delete]]

      #+BEGIN_SRC ocaml
        val delete_rule_in_tree: internal_entry -> symbol list -> tree -> (symbol list option * tree) option
        val decr_keyw_use: gram -> symbol -> unit
        (* given the input [symbol], have side effect on gram *)
        val decr_keyw_use_in_tree: gram -> tree -> unit
        val delete_rule_in_suffix: internal_entry -> symbol list -> level list -> level list
        val delete_rule_in_prefix: internal_entry -> symbol list ->
                                   level list -> level list
        val delete_rule_in_level_list: internal_entry -> symbol list -> level list -> level list 
        val delete_rule: internal_entry -> symbol list -> unit                                                                                
      #+END_SRC

***** [[file:~/camlp4/src/Grammar/Static.ml][Static]]

      Re-export the APIs of all previous modules
      The difference between Static and Dynamic is that in static,
      gram is fixed.

      #+BEGIN_SRC ocaml
        module Entry = struct
          module E = Entry.Make Structure;
          type t 'a = E.t 'a;
          value mk = E.mk gram;
          value of_parser name strm = E.of_parser gram name strm;
          value setup_parser = E.setup_parser;
          value name = E.name;
          value print = E.print;
          value clear = E.clear;
          value dump = E.dump;
        
          value obj x = x;
        end;
        
      #+END_SRC

***** [[file:~/camlp4/src/Grammar/Dynamic.ml][Dynamic]]
      


**** grammar parser

     #+BEGIN_SRC ocaml
       type 'e name ={
         expr: 'e;
         tvar: string;
         loc: loc
       }
       type styp =
         | STlid of loc * string
         | STapp of loc * styp * styp
         | STquo of loc * string
         | STself of loc * string  (* type variable *)
         | STtok of loc (* <:ctyp< $uid:gm.Token.t >> *)
         | STstring_tok of loc (* string type *)
         | STtyp of Ast.ctyp (* specified by the user *)
       
       type ('e,'p) text =
         | TXmeta of loc * string * ('e,'p) text list * 'e * styp (* ==> Smeta ==> FOLD0 , FOLD1 *)
         | TXlist of loc * bool * ('e,'p) symbol * ('e,'p) symbol option
         | TXnext of loc
         | TXnterm of loc * 'e name * string option
         | TXopt o f loc * ('e,'p) text
         | TXtry of loc * ('e,'p) text
         | TXrules of loc * (('e,'p)text list *'e) list
         | TXself of loc
         | TXkwd of loc * string
         | TXtok of loc * 'e * string
         (* the second should be normalized and  well comparable *)
        and ('e,'p) entry = {
          name: 'e name;
          pos: 'e option;
          levels: (('e,'p) level) list;
        }
        and ('e,'p) level = {
          label: string option;
          assoc: 'e option;
          levels: (('e,'p) rule) list
        }
        and ('e,'p) rule = {
          prod: (('e,'p) symbol) list;
          action: 'e option
        }
        and ('e,'p) symbol = {
          used: string list;
          text: ('e,'p) text;
          styp: styp;
          pattern: 'p option
        }
       
       val mark_used : bool ref -> ('a, used ref * 'b) Hashtbl.t -> 'a -> unit
       val mark_symbol :
         bool ref ->
         (string, used ref * 'a) Hashtbl.t -> ('b, 'c) symbol -> unit
       val check_use : 'a name list -> (Ast.expr, 'b) entry list -> unit
       val new_type_var : unit -> string
       val used_of_rule_list : ('a, 'b) rule list -> string list
       val make_ctyp: styp -> string -> Ast.ctyp                        
       val make_ctyp_patt: styp -> string -> Ast.patt -> Ast.patt 
       val make_ctyp_expr: styp -> string -> Ast.expr -> Ast.expr 
       val text_of_action: Ast.loc -> ('a,Ast.patt) symbol list ->
                           string -> Ast.expr option -> string -> Ast.expr
       val srules: Ast.loc -> string -> (Ast.expr,Ast.patt) rule list ->
                   string -> ( (Ast.expr,Ast.patt)text list * Ast.expr) list
       
     #+END_SRC
** TODO Register mechanism

   (string,module Sig.PLUGIN) Hashtbl.t

   -parsers
   comman_or_blank_sep_strings [[file:~/ocaml/ocamlbuild/lexers.mli][lexer]]
   delayed

**** debugging
     Faild module tree_failed will print the error message, since
     [TRY] introduces backtracking

     #+BEGIN_SRC ocaml
       [ [ t1 = SELF; "as"; "'"; i = a_ident -> <:ctyp< $t1 as '$i >> ]
       | "arrow" RA
         [ t1 = SELF; "->"; t2 = SELF -> <:ctyp< $t1 -> $t2 >>
         | i = TRY [i = a_LIDENT; ":" -> i]; t1 = ctyp Level "star"; "->"; t2 = SELF
                ->  <:ctyp< ( ~ $i : $t1 ) -> $t2 >>
         | i = a_OPTLABEL; t1 = ctyp Level "star"; "->"; t2 = SELF ->
            <:ctyp< ( ? $i : $t1 ) -> $t2 >>
         | "?"; i = a_LIDENT; ":"; t1 = ctyp Level "star"; "->"; t2 = SELF ->
            <:ctyp< ( ? $i : $t1 ) -> $t2 >> ]
       | "star"
           [ t = SELF; "*"; tl = star_ctyp -> <:ctyp< ( $t * $tl ) >> ]
       | "ctyp1"
           [ t1 = SELF; t2 = SELF -> <:ctyp< $t2 $t1 >> ]
       | "ctyp2"
           [ t1 = SELF; "."; t2 = SELF ->
              try <:ctyp< $(id:Ast.ident_of_ctyp t1).$(id:Ast.ident_of_ctyp t2) >>
              with [ Invalid_argument s -> raise (Stream.Error s) ]
           | t1 = SELF; "("; t2 = SELF; ")" ->
              let t = <:ctyp< $t1 $t2 >> in
              try <:ctyp< $(id:Ast.ident_of_ctyp t) >>
              with [ Invalid_argument s -> raise (Stream.Error s) ] ]
       | "simple"
           [ "'"; i = a_ident -> <:ctyp< '$i >>
           | "_" -> <:ctyp< _ >>
           | i = a_LIDENT -> <:ctyp< $lid:i >>
           | i = a_UIDENT -> <:ctyp< $uid:i >>
           | `ANTIQUOT (""|"typ"|"anti" as n) s ->
              <:ctyp< $(anti:mk_anti ~c:"ctyp" n s) >>
           | `ANTIQUOT ("tup" as n) s ->
              <:ctyp< ($(tup:<:ctyp< $(anti:mk_anti ~c:"ctyp" n s) >>)) >>
           | `ANTIQUOT ("id" as n) s ->
              <:ctyp< $(id:<:ident< $(anti:mk_anti ~c:"ident" n s) >>) >>
           | `QUOTATION x -> Quotation.expand _loc x Quotation.DynAst.ctyp_tag
           | "("; t = SELF; ","; mk = comma_ctyp_app; ")";
             i = ctyp Level "ctyp2" ->
              mk <:ctyp< $i $t >>
           | "("; t = SELF; ")" -> <:ctyp< $t >>
           | "#"; i = class_longident -> <:ctyp< # $i >>
           | "<"; t = opt_meth_list; ">" -> t
           | "["; OPT "|"; rfl = row_field; "]" ->
              <:ctyp< [ = $rfl ] >>
           | "["; ">"; "]" -> <:ctyp< [ > $(<:ctyp<>>) ] >>
           | "["; ">"; OPT "|"; rfl = row_field; "]" ->
              <:ctyp< [ > $rfl ] >>
           | "[<"; OPT "|"; rfl = row_field; "]" ->
              <:ctyp< [ < $rfl ] >>
           | "[<"; OPT "|"; rfl = row_field; ">"; ntl = name_tags; "]" ->
              <:ctyp< [ < $rfl > $ntl ] >>
           | "("; "module"; p = package_type; ")" -> <:ctyp< (module $p) >> ] ]
         
     #+END_SRC

     #+BEGIN_SRC ocaml
       fun_binding:
         [ RA
           [ TRY ["("; "type"]; i = a_LIDENT; ")"; e = SELF
             -> <:expr< fun (type $i) -> $e >>
           | p = TRY labeled_ipatt; e = SELF ->
              <:expr< fun $p -> $e >>
           | bi = cvalue_binding -> bi
             ] ];
     #+END_SRC

     #+BEGIN_SRC ocaml
       cvalue_binding:
         [ [ "="; e = expr -> e
           | ":"; "type"; t1 = unquoted_typevars; "." ; t2 = ctyp ; "="; e = expr -> 
              let u = Ast.TyTypePol _loc t1 t2 in
              <:expr< ($e : $u) >>
           | ":"; t = poly_type; "="; e = expr -> <:expr< ($e : $t) >>
           | ":"; t = poly_type; ":>"; t2 = ctyp; "="; e = expr ->
              match t with
                [ <:ctyp< ! $_ . $_ >> -> raise (Stream.Error "unexpected polytype here")
                | _ -> <:expr< ($e : $t :> $t2) >> ]
           | ":>"; t = ctyp; "="; e = expr -> <:expr< ($e :> $t) >> ] ]
       fun_binding:
       [ RA
       [ TRY ["("; "type"]; i = a_LIDENT; ")"; e = SELF
          ->  <:expr< fun (type $i) -> $e >>
       | p = TRY labeled_ipatt; e = SELF ->
          <:expr< fun $p -> $e >>
       | bi = cvalue_binding -> bi ] ]
       let_binding:
       [ [ p = ipatt; e = fun_binding -> <:binding< $p = $e >> ] ]
       binding:
       [ LA
        `ANTIQUOT ("binding"|"list" as n) s ->
         <:binding< $(anti:mk_anti ~c:"binding" n s) >>
       | `ANTIQUOT (""|"anti" as n) s; "="; e = expr ->
          <:binding< $(anti:mk_anti ~c:"patt" n s) = $e >>
       | `ANTIQUOT (""|"anti" as n) s -> <:binding< $(anti:mk_anti ~c:"binding" n s) >>
       | b1 = SELF; "and"; b2 = SELF -> <:binding< $b1 and $b2 >>
       | b = let_binding -> b ] 

       [ "let"; r = opt_rec; bi = binding; "in"; x = SELF ->
            <:expr< let $rec:r $bi in $x >> ]

       | o = value_val_opt_override; mf = opt_mutable; lab = label; e = cvalue_binding 
          ->
            <:class_str_item< value $override:o $mutable:mf $lab = $e >>

     #+END_SRC

     #+BEGIN_SRC ocaml
Error: Syntax error
let f : ('a . 'a -> 'a ) = fun x -> x;;
Characters 12-13:
  let f : ('a . 'a -> 'a ) = fun x -> x;;
              ^
Error: Syntax error
let f : 'a . 'a -> 'a  = fun x -> x;;
val f : 'a -> 'a = <fun>

let_binding:
    val_ident fun_binding
      { (mkpatvar $1 1, $2) }
  | val_ident COLON typevar_list DOT core_type EQUAL seq_expr
      { (ghpat(Ppat_constraint(mkpatvar $1 1, ghtyp(Ptyp_poly($3,$5)))), $7) }
  | val_ident COLON TYPE lident_list DOT core_type EQUAL seq_expr
      { let exp, poly = wrap_type_annotation $4 $6 $8 in
        (ghpat(Ppat_constraint(mkpatvar $1 1, poly)), exp) }
  | pattern EQUAL seq_expr
      { ($1, $3) }
     
     #+END_SRC

     #+BEGIN_SRC ocaml
value f : ! a. a -> a  = fun [x -> x];
Characters 10-11:
  value f : ! a. a -> a  = fun [x -> x];
            ^
Error: Parse error: [typevars] expected after "!" (in [ctyp])
value f : ! 'a. 'a -> 'a  = fun [x -> x];
value f : ! 'a. 'a -> 'a  = fun [x -> x];
value f : 'a -> 'a = <fun>
value f : (! 'a. 'a -> 'a)  = fun [x -> x];
value f : (! 'a. 'a -> 'a)  = fun [x -> x];
value f : 'a -> 'a = <fun>
     #+END_SRC
* ideas
  

** take a look at design of xstrp4
   how to make
   =/fprintf ppf "ghso" more simple /=

   =/<:fmt<Illegal character ($(Char.escaped c))>>/=

   the quotation fmt can config which "fprintf" was used actually,
   like "bprintf", "ifprintf", "eprintf"
** integrating ulex
   an extensible lexer?


* Formalize quot-antiquot

  #+BEGIN_SRC ocaml
  a_INT:
      [ [ `ANTIQUOT (""|"int"|"`int" as n) s -> mk_anti n s
        | `INT _ s -> s ] ] 
  #+END_SRC


  #+BEGIN_SRC ocaml
    expr:
      | "simple"
        [ `QUOTATION x -> Quotation.expand _loc x DynAst.expr_tag
        | `ANTIQUOT ("exp"|""|"anti" as n) s ->
            <:expr< $(anti:mk_anti ~c:"expr" n s) >>
        | `ANTIQUOT ("`bool" as n) s ->
            <:expr< $(id:<:ident< $(anti:mk_anti n s) >>) >>
        | `ANTIQUOT ("tup" as n) s ->
            <:expr< $(tup: <:expr< $(anti:mk_anti ~c:"expr" n s) >>) >>
        | `ANTIQUOT ("seq" as n) s ->
            <:expr< do $(anti:mk_anti ~c:"expr" n s) done >>
        | s = a_INT -> <:expr< $int:s >>
        | s = a_INT32 -> <:expr< $int32:s >>

  #+END_SRC

  how

  #+BEGIN_SRC ocaml
    <:expr< $int:s >>

   QUOTATION "$int:s"


   ANTIQUOT "int"  s


   parsed by the entry a_INT => "\\$int:"^s  ==>

   Ast.ExInt _loc ("\\$int:" ^ s)

  #+END_SRC

