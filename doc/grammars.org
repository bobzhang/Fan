#+SEQ_TODO: TODO(T) WAIT(W) | DONE(D!) CANCELED(C@) 
#+STARTUP: overview
#+COLUMNS: %10ITEM  %10PRIORITY %15TODO %65TAGS

#+OPTIONS: toc:4 ^:{} num:nil creator:nil author:nil
#+OPTIONS: author:nil timestamp:nil d:nil
#+STYLE: <link rel="stylesheet" type="text/css" href="../css/style.css">


Grammars


Grammars are tricky, so I recorded some modifications I made in case
some bugs happenend here.



* sig item

** sig_items

  #+BEGIN_SRC ocaml
    [ [ `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s ->
       <:sig_item< $(anti:mk_anti n ~c:"sig_item" s) >>
      | `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s; semi; sg = SELF ->
         <:sig_item< $(anti:mk_anti n ~c:"sig_item" s); $sg >>
      | l = LIST0 [ sg = sig_item; semi -> sg ] -> Ast.sgSem_of_list l
    ] ]
  #+END_SRC  

** sig_item

  #+BEGIN_SRC ocaml
    [ "top"
    [ `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s ->
      <:sig_item< $(anti:mk_anti ~c:"sig_item" n s) >>
    | `QUOTATION x -> Quotation.expand _loc x DynAst.sig_item_tag
    | "exception"; t = constructor_declaration ->
       <:sig_item< exception $t >>
    | "external"; i = a_LIDENT; ":"; t = ctyp; "="; sl = string_list ->
       <:sig_item< external $i : $t = $sl >>
    | "include"; mt = module_type -> <:sig_item< include $mt >>
    | "module"; i = a_UIDENT; mt = module_declaration ->
       <:sig_item< module $i : $mt >>
    | "module"; "rec"; mb = module_rec_declaration ->
       <:sig_item< module rec $mb >>
    | "module"; "type"; i = a_ident; "="; mt = module_type ->
       <:sig_item< module type $i = $mt >>
    | "module"; "type"; i = a_ident ->
       <:sig_item< module type $i >>
    | "open"; i = module_longident -> <:sig_item< open $i >>
    | "type"; t = type_declaration ->
       <:sig_item< type $t >>
    | value_val; i = a_LIDENT; ":"; t = ctyp ->
       <:sig_item< value $i : $t >>
    | "class"; cd = class_description ->
       <:sig_item< class $cd >>
    | "class"; "type"; ctd = class_type_declaration ->
       <:sig_item< class type $ctd >> ] ]  
  #+END_SRC
** sig_items
  #+BEGIN_SRC ocaml
    [ [ `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s ->
       <:sig_item< $(anti:mk_anti n ~c:"sig_item" s) >>
    | `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s; semi; sg = SELF ->
       <:sig_item< $(anti:mk_anti n ~c:"sig_item" s); $sg >>
    | l = LIST0 [ sg = sig_item; semi -> sg ] -> Ast.sgSem_of_list l
    ] ]  
  #+END_SRC

** class_sig_item

  #+BEGIN_SRC ocaml
    [ [ `ANTIQUOT (""|"csg"|"anti"|"list" as n) s ->
        <:class_sig_item< $(anti:mk_anti ~c:"class_sig_item" n s) >>
      | `QUOTATION x -> Quotation.expand _loc x DynAst.class_sig_item_tag
      | "inherit"; cs = class_type ->
         <:class_sig_item< inherit $cs >>
      | value_val; mf = opt_mutable; mv = opt_virtual;
        l = label; ":"; t = ctyp ->
         <:class_sig_item< value $mutable:mf $virtual:mv $l : $t >>
      | "method"; "virtual"; pf = opt_private; l = label; ":"; t = poly_type ->
         <:class_sig_item< method virtual $private:pf $l : $t >>
      | "method"; pf = opt_private; l = label; ":"; t = poly_type ->
         <:class_sig_item< method $private:pf $l : $t >>
      | "method"; pf = opt_private; "virtual"; l = label; ":"; t = poly_type ->
         <:class_sig_item< method virtual $private:pf $l : $t >>
      | type_constraint; t1 = ctyp; "="; t2 = ctyp ->
         <:class_sig_item< type $t1 = $t2 >> ] ]
      
  #+END_SRC

** interf
  #+BEGIN_SRC ocaml
    [ [ "#"; n = a_LIDENT; dp = opt_expr; semi ->
        ([ <:sig_item< # $n $dp >> ], stopped_at _loc)
      | si = sig_item; semi; (sil, stopped) = SELF -> ([si :: sil], stopped)
      | `EOI -> ([], None) ] ]
      
  #+END_SRC

** sig_item_quot

  #+BEGIN_SRC ocaml
    [ [ "#"; n = a_LIDENT; dp = opt_expr -> <:sig_item< # $n $dp >>
      | sg1 = sig_item; semi; sg2 = SELF ->
        match sg2 with
       [ <:sig_item<>> -> sg1
       | _ -> <:sig_item< $sg1; $sg2 >> ]
        | sg = sig_item -> sg
        | -> <:sig_item<>>
      ]]  
  #+END_SRC

** class_sig_item_quot

  #+BEGIN_SRC ocaml
    [ [ x1 = class_sig_item; semi; x2 = SELF ->
        match x2 with
        [ <:class_sig_item<>> -> x1
        | _ -> <:class_sig_item< $x1; $x2 >> ]
        | x = class_sig_item -> x
        | -> <:class_sig_item<>> ] ]
  #+END_SRC


  #+BEGIN_SRC ocaml
    add_quotation "class_sig_item"
                  class_sig_item_quot ME.meta_class_sig_item MP.meta_class_sig_item
  #+END_SRC  


* str item

** implem

   #+BEGIN_SRC ocaml
     [ [ "#"; n = a_LIDENT; dp = opt_expr; semi ->
         ([ <:str_item< # $n $dp >> ], stopped_at _loc)
       | si = str_item; semi; (sil, stopped) = SELF -> ([si :: sil], stopped)
       | `EOI -> ([], None)
     ] ]   
   #+END_SRC

** str_item

   #+BEGIN_SRC ocaml
     [ "top"
       [ "exception"; t = constructor_declaration ->
          <:str_item< exception $t >>
       | "exception"; t = constructor_declaration; "="; i = type_longident ->
          <:str_item< exception $t = $i >>
       | "external"; i = a_LIDENT; ":"; t = ctyp; "="; sl = string_list ->
          <:str_item< external $i : $t = $sl >>
       | "include"; me = module_expr -> <:str_item< include $me >>
       | "module"; i = a_UIDENT; mb = module_binding0 ->
          <:str_item< module $i = $mb >>
       | "module"; "rec"; mb = module_binding ->
          <:str_item< module rec $mb >>
       | "module"; "type"; i = a_ident; "="; mt = module_type ->
          <:str_item< module type $i = $mt >>
       | "open"; i = module_longident -> <:str_item< open $i >>
       | "type"; td = type_declaration ->
          <:str_item< type $td >>
       | value_let; r = opt_rec; bi = binding ->
          <:str_item< value $rec:r $bi >>
       | "class"; cd = class_declaration ->
          <:str_item< class $cd >>
       | "class"; "type"; ctd = class_type_declaration ->
         <:str_item< class type $ctd >>
       | `ANTIQUOT (""|"stri"|"anti"|"list" as n) s ->
         <:str_item< $(anti:mk_anti ~c:"str_item" n s) >>
               (*
                   first, it gives "mk_anti ~c:"str_item" n s" , and then through
                   the meta operation, it gets
                   (Ast.StAnt (_loc, ( (mk_anti ~c:"str_item" n s) )))
                  *)
       | `QUOTATION x -> Quotation.expand _loc x DynAst.str_item_tag
       | e = expr -> <:str_item< $exp:e >>
         (* this entry makes <:str_item< let $rec:r $bi in $x >> parsable *)
       ] ]   
   #+END_SRC
** str_items

   #+BEGIN_SRC ocaml
     [ [ `ANTIQUOT (""|"stri"|"anti"|"list" as n) s ->
         <:str_item< $(anti:mk_anti n ~c:"str_item" s) >>
       | `ANTIQUOT (""|"stri"|"anti"|"list" as n) s; semi; st = SELF ->
          <:str_item< $(anti:mk_anti n ~c:"str_item" s); $st >>
       | l = LIST0 [ st = str_item; semi -> st ] -> Ast.stSem_of_list l
     ] ]   
   #+END_SRC
   it was used in

   #+BEGIN_SRC ocaml
        | "struct"; st = str_items; "end" ->
            <:module_expr< struct $st end >>   
   #+END_SRC
** class_str_item

   #+BEGIN_SRC ocaml
     [ LA
       [ `ANTIQUOT (""|"cst"|"anti"|"list" as n) s ->
         <:class_str_item< $(anti:mk_anti ~c:"class_str_item" n s) >>
       | `QUOTATION x -> Quotation.expand _loc x DynAst.class_str_item_tag
       | "inherit"; o = opt_override; ce = class_expr; pb = opt_as_lident ->
          <:class_str_item< inherit $override:o $ce as $pb >>
       | o = value_val_opt_override; mf = opt_mutable; lab = label; e = cvalue_binding
               ->
         <:class_str_item< value $override:o $mutable:mf $lab = $e >>
       | o = value_val_opt_override; mf = opt_mutable; "virtual"; l = label; ":";  t = poly_type ->
                 if o <> <:override_flag<>> then
                   raise (Stream.Error "override (!) is incompatible with virtual")
                 else
                   <:class_str_item< value virtual $mutable:mf $l : $t >>
       | o = value_val_opt_override; "virtual"; mf = opt_mutable; l = label; ":"; t = poly_type ->
                 if o <> <:override_flag<>> then
                   raise (Stream.Error "override (!) is incompatible with virtual")
                 else
                   <:class_str_item< value virtual $mutable:mf $l : $t >>
       | o = method_opt_override; "virtual"; pf = opt_private; l = label; ":"; t = poly_type ->
                 if o <> <:override_flag<>> then
                   raise (Stream.Error "override (!) is incompatible with virtual")
                 else
                   <:class_str_item< method virtual $private:pf $l : $t >>
       | o = method_opt_override; pf = opt_private; l = label; topt = opt_polyt; e = fun_binding ->
                 <:class_str_item< method $override:o $private:pf $l : $topt = $e >>
       | o = method_opt_override; pf = opt_private; "virtual"; l = label; ":"; t = poly_type ->
                 if o <> <:override_flag<>> then
                   raise (Stream.Error "override (!) is incompatible with virtual")
                 else
                   <:class_str_item< method virtual $private:pf $l : $t >>
       | type_constraint; t1 = ctyp; "="; t2 = ctyp ->
               <:class_str_item< type $t1 = $t2 >>
       | "initializer"; se = expr -> <:class_str_item< initializer $se >> ] ]   
   #+END_SRC
   


** str_item_quot

   #+BEGIN_SRC ocaml
     [ [ "#"; n = a_LIDENT; dp = opt_expr -> <:str_item< # $n $dp >>
     | st1 = str_item; semi; st2 = SELF ->
        match st2 with
        [ <:str_item<>> -> st1
        | _ -> <:str_item< $st1; $st2 >> ]
        | st = str_item -> st
     | -> <:str_item<>> ] ]   
   #+END_SRC


* semi
  either ";;" or ";" or nil
