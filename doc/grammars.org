#+SEQ_TODO: TODO(T) WAIT(W) | DONE(D!) CANCELED(C@) 
#+STARTUP: overview
#+COLUMNS: %10ITEM  %10PRIORITY %15TODO %65TAGS

#+OPTIONS: toc:4 ^:{} num:nil creator:nil author:nil
#+OPTIONS: author:nil timestamp:nil d:nil
#+STYLE: <link rel="stylesheet" type="text/css" href="../css/style.css">


Grammars


Grammars are tricky, so I recorded some modifications I made in case
some bugs happenend here.



* sig item
  
** sig_items

  #+BEGIN_SRC ocaml
    [ [ `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s ->
       <:sig_item< $(anti:mk_anti n ~c:"sig_item" s) >>
      | `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s; semi; sg = SELF ->
         <:sig_item< $(anti:mk_anti n ~c:"sig_item" s); $sg >>
      | l = LIST0 [ sg = sig_item; semi -> sg ] -> Ast.sgSem_of_list l
    ] ]
  #+END_SRC  

** sig_item

  #+BEGIN_SRC ocaml
    [ "top"
    [ `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s ->
      <:sig_item< $(anti:mk_anti ~c:"sig_item" n s) >>
    | `QUOTATION x -> Quotation.expand _loc x DynAst.sig_item_tag
    | "exception"; t = constructor_declaration ->
       <:sig_item< exception $t >>
    | "external"; i = a_LIDENT; ":"; t = ctyp; "="; sl = string_list ->
       <:sig_item< external $i : $t = $sl >>
    | "include"; mt = module_type -> <:sig_item< include $mt >>
    | "module"; i = a_UIDENT; mt = module_declaration ->
       <:sig_item< module $i : $mt >>
    | "module"; "rec"; mb = module_rec_declaration ->
       <:sig_item< module rec $mb >>
    | "module"; "type"; i = a_ident; "="; mt = module_type ->
       <:sig_item< module type $i = $mt >>
    | "module"; "type"; i = a_ident ->
       <:sig_item< module type $i >>
    | "open"; i = module_longident -> <:sig_item< open $i >>
    | "type"; t = type_declaration ->
       <:sig_item< type $t >>
    | value_val; i = a_LIDENT; ":"; t = ctyp ->
       <:sig_item< value $i : $t >>
    | "class"; cd = class_description ->
       <:sig_item< class $cd >>
    | "class"; "type"; ctd = class_type_declaration ->
       <:sig_item< class type $ctd >> ] ]  
  #+END_SRC
** sig_items
  #+BEGIN_SRC ocaml
    [ [ `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s ->
       <:sig_item< $(anti:mk_anti n ~c:"sig_item" s) >>
    | `ANTIQUOT (""|"sigi"|"anti"|"list" as n) s; semi; sg = SELF ->
       <:sig_item< $(anti:mk_anti n ~c:"sig_item" s); $sg >>
    | l = LIST0 [ sg = sig_item; semi -> sg ] -> Ast.sgSem_of_list l
    ] ]  
  #+END_SRC

** class_sig_item

  #+BEGIN_SRC ocaml
    [ [ `ANTIQUOT (""|"csg"|"anti"|"list" as n) s ->
        <:class_sig_item< $(anti:mk_anti ~c:"class_sig_item" n s) >>
      | `QUOTATION x -> Quotation.expand _loc x DynAst.class_sig_item_tag
      | "inherit"; cs = class_type ->
         <:class_sig_item< inherit $cs >>
      | value_val; mf = opt_mutable; mv = opt_virtual;
        l = label; ":"; t = ctyp ->
         <:class_sig_item< value $mutable:mf $virtual:mv $l : $t >>
      | "method"; "virtual"; pf = opt_private; l = label; ":"; t = poly_type ->
         <:class_sig_item< method virtual $private:pf $l : $t >>
      | "method"; pf = opt_private; l = label; ":"; t = poly_type ->
         <:class_sig_item< method $private:pf $l : $t >>
      | "method"; pf = opt_private; "virtual"; l = label; ":"; t = poly_type ->
         <:class_sig_item< method virtual $private:pf $l : $t >>
      | type_constraint; t1 = ctyp; "="; t2 = ctyp ->
         <:class_sig_item< type $t1 = $t2 >> ] ]
      
  #+END_SRC

** interf
  #+BEGIN_SRC ocaml
    [ [ "#"; n = a_LIDENT; dp = opt_expr; semi ->
        ([ <:sig_item< # $n $dp >> ], stopped_at _loc)
      | si = sig_item; semi; (sil, stopped) = SELF -> ([si :: sil], stopped)
      | `EOI -> ([], None) ] ]
      
  #+END_SRC

** sig_item_quot

  #+BEGIN_SRC ocaml
    [ [ "#"; n = a_LIDENT; dp = opt_expr -> <:sig_item< # $n $dp >>
      | sg1 = sig_item; semi; sg2 = SELF ->
        match sg2 with
       [ <:sig_item<>> -> sg1
       | _ -> <:sig_item< $sg1; $sg2 >> ]
        | sg = sig_item -> sg
        | -> <:sig_item<>>
      ]]  
  #+END_SRC

** class_sig_item_quot

  #+BEGIN_SRC ocaml
    [ [ x1 = class_sig_item; semi; x2 = SELF ->
        match x2 with
        [ <:class_sig_item<>> -> x1
        | _ -> <:class_sig_item< $x1; $x2 >> ]
        | x = class_sig_item -> x
        | -> <:class_sig_item<>> ] ]
  #+END_SRC


  #+BEGIN_SRC ocaml
    add_quotation "class_sig_item"
                  class_sig_item_quot ME.meta_class_sig_item MP.meta_class_sig_item
  #+END_SRC  


* str item

** implem

   #+BEGIN_SRC ocaml
     [ [ "#"; n = a_LIDENT; dp = opt_expr; semi ->
         ([ <:str_item< # $n $dp >> ], stopped_at _loc)
       | si = str_item; semi; (sil, stopped) = SELF -> ([si :: sil], stopped)
       | `EOI -> ([], None)
     ] ]   
   #+END_SRC

** str_item

   #+BEGIN_SRC ocaml
     [ "top"
       [ "exception"; t = constructor_declaration ->
          <:str_item< exception $t >>
       | "exception"; t = constructor_declaration; "="; i = type_longident ->
          <:str_item< exception $t = $i >>
       | "external"; i = a_LIDENT; ":"; t = ctyp; "="; sl = string_list ->
          <:str_item< external $i : $t = $sl >>
       | "include"; me = module_expr -> <:str_item< include $me >>
       | "module"; i = a_UIDENT; mb = module_binding0 ->
          <:str_item< module $i = $mb >>
       | "module"; "rec"; mb = module_binding ->
          <:str_item< module rec $mb >>
       | "module"; "type"; i = a_ident; "="; mt = module_type ->
          <:str_item< module type $i = $mt >>
       | "open"; i = module_longident -> <:str_item< open $i >>
       | "type"; td = type_declaration ->
          <:str_item< type $td >>
       | value_let; r = opt_rec; bi = binding ->
          <:str_item< value $rec:r $bi >>
       | "class"; cd = class_declaration ->
          <:str_item< class $cd >>
       | "class"; "type"; ctd = class_type_declaration ->
         <:str_item< class type $ctd >>
       | `ANTIQUOT (""|"stri"|"anti"|"list" as n) s ->
         <:str_item< $(anti:mk_anti ~c:"str_item" n s) >>
               (*
                   first, it gives "mk_anti ~c:"str_item" n s" , and then through
                   the meta operation, it gets
                   (Ast.StAnt (_loc, ( (mk_anti ~c:"str_item" n s) )))
                  *)
       | `QUOTATION x -> Quotation.expand _loc x DynAst.str_item_tag
       | e = expr -> <:str_item< $exp:e >>
         (* this entry makes <:str_item< let $rec:r $bi in $x >> parsable *)
       ] ]   
   #+END_SRC
** str_items

   #+BEGIN_SRC ocaml
     [ [ `ANTIQUOT (""|"stri"|"anti"|"list" as n) s ->
         <:str_item< $(anti:mk_anti n ~c:"str_item" s) >>
       | `ANTIQUOT (""|"stri"|"anti"|"list" as n) s; semi; st = SELF ->
          <:str_item< $(anti:mk_anti n ~c:"str_item" s); $st >>
       | l = LIST0 [ st = str_item; semi -> st ] -> Ast.stSem_of_list l
     ] ]   
   #+END_SRC
   it was used in

   #+BEGIN_SRC ocaml
        | "struct"; st = str_items; "end" ->
            <:module_expr< struct $st end >>   
   #+END_SRC
** class_str_item

   #+BEGIN_SRC ocaml
     [ LA
       [ `ANTIQUOT (""|"cst"|"anti"|"list" as n) s ->
         <:class_str_item< $(anti:mk_anti ~c:"class_str_item" n s) >>
       | `QUOTATION x -> Quotation.expand _loc x DynAst.class_str_item_tag
       | "inherit"; o = opt_override; ce = class_expr; pb = opt_as_lident ->
          <:class_str_item< inherit $override:o $ce as $pb >>
       | o = value_val_opt_override; mf = opt_mutable; lab = label; e = cvalue_binding
               ->
         <:class_str_item< value $override:o $mutable:mf $lab = $e >>
       | o = value_val_opt_override; mf = opt_mutable; "virtual"; l = label; ":";  t = poly_type ->
                 if o <> <:override_flag<>> then
                   raise (Stream.Error "override (!) is incompatible with virtual")
                 else
                   <:class_str_item< value virtual $mutable:mf $l : $t >>
       | o = value_val_opt_override; "virtual"; mf = opt_mutable; l = label; ":"; t = poly_type ->
                 if o <> <:override_flag<>> then
                   raise (Stream.Error "override (!) is incompatible with virtual")
                 else
                   <:class_str_item< value virtual $mutable:mf $l : $t >>
       | o = method_opt_override; "virtual"; pf = opt_private; l = label; ":"; t = poly_type ->
                 if o <> <:override_flag<>> then
                   raise (Stream.Error "override (!) is incompatible with virtual")
                 else
                   <:class_str_item< method virtual $private:pf $l : $t >>
       | o = method_opt_override; pf = opt_private; l = label; topt = opt_polyt; e = fun_binding ->
                 <:class_str_item< method $override:o $private:pf $l : $topt = $e >>
       | o = method_opt_override; pf = opt_private; "virtual"; l = label; ":"; t = poly_type ->
                 if o <> <:override_flag<>> then
                   raise (Stream.Error "override (!) is incompatible with virtual")
                 else
                   <:class_str_item< method virtual $private:pf $l : $t >>
       | type_constraint; t1 = ctyp; "="; t2 = ctyp ->
               <:class_str_item< type $t1 = $t2 >>
       | "initializer"; se = expr -> <:class_str_item< initializer $se >> ] ]   
   #+END_SRC
   


** str_item_quot

   #+BEGIN_SRC ocaml
     [ [ "#"; n = a_LIDENT; dp = opt_expr -> <:str_item< # $n $dp >>
     | st1 = str_item; semi; st2 = SELF ->
        match st2 with
        [ <:str_item<>> -> st1
        | _ -> <:str_item< $st1; $st2 >> ]
        | st = str_item -> st
     | -> <:str_item<>> ] ]   
   #+END_SRC


* semi
  either ";;" or ";" or nil

* syntax difference
  
** lexing
   '\''
   '''

** module
   let x = 42 ;;
   value x = 42;

   let x = 42 in x + 7 ;;
   let x = 42 in x + 7 ;

   val x:int;;
   value x: int;

   (* signatures, abstract module types*)
   module type MT;;
   module type MT='a;

   type t = Set.Make(M).t;;
   type t = (Set.Make M).t;

   module M = Mod.Make (M1) (M2);;
   module M = Mod.Make M1 M2;
   
** expression and patterns
   e1;e2;e3;e4
   do {e1;e2;e3;e4}

   while e1 do
     e1;e2;e3
   done

   while e1 do{
     e1;e2;e3
   }
   
   for i = e1 to e2 do
     e1;e2;e3
   done

   for i = e1 to e2 do{
     e1;e2;e3
   }

   1,2
   (1,2)

   x::y
   [x::y]

   [x;y;z]
   [x;y;z]

   x::y::z::t
   [x;y;z::t]

   {e with field = a}
   {(e) with field = a}

   {field = fun a -> e}
   {field a = e}

   syntactic irrefutable pattern 

   function no longer exists, only "fun"

   match e with p1  -> e1 | p2 -> e2
   match e with [p1 -> e1 | p2 -> e2]
   (if there is only one case and if the
   pattern is irrefutable, the brackets
   are not required, hey optinoal, is a good
   idea, when you writing quotations, you be
   cautious, when you write code outside,
   you don't add them
   )

   fun x -> x
   fun x -> x

   fun {foo=(y,_)} -> y
   fun {foo=(y,_)} -> y

   let f (x::y) = ..
   let f = fun [ [x::y] -> ]

   x.f <- y
   x.f := y

   x:=!x + y  =FIXEd=
   x.val := x.val + y

   if a then b
   if a then b else ()

   a or b & c
   a || b && c

   no more "begin end" construction

   function Some a as b , c ->
   fun [((Some a as b), c) -> ]

   function Some a as b ->
   fun [Some a as b -> ]

   int list
   list int

   ('a,bool) Hashtbl.t
   Hashtbl.t 'a bool

   type 'a foo = 'a list list
   type foo 'a = list (list 'a)

   type 'a foo
   type foo 'a = 'b

   
   type bar
   type bar = 'a

   int * bool
   (int * bool)

   type t = A of i | B
   type t =  [A of i | B]

   type t = C of t1 * t2
   type t = [C of t1 and t2 ]

   C(x,y)
   C x y

   type t = D of (t1*t2)
   type t = [D of (t1 * t2)]

   D (x,y)
   D (x,y)

   true && false
   True && False

   type t = {mutable x:t1}
   type t = {x:mutable t1}

   type 'a t = 'a option =
      None
     | Some of 'a
   type t 'a = option 'a ==
     [None
     |Some of 'a]
   
   type t = {f:'a. 'a list}
   type t = {f: ! 'a.  list 'a}

   [< '1; '2; s; '3>]
   [: `1; `2 ; s; `3 :]

   parser
   [< 'Foo >] -> e
   | [< p=f >] -> f |

   parser
   [ [: `Foo :] -> e
   | [: p = f :] -> f ] |

   parser [: `x :] -> x

** objects
   class ['a,'b] point =
   class point ['a,'b] =

   class c = [int] color
   classs c = color [int]

   (* class signature *)
   class c : int -> point
   class c : [int] -> point 
   
   the keywords "virtual" and "private"
   must be in order in revised syntax

   object val x = 3 end
   object value x =  3; end

   object constraint 'a = int end
   object type 'a = int; end


** labels and variants

   val x: num:int -> bool
   value x : ~num:int -> bool

   type t = [`On | `Off]
   type t = [ = `On | `Off]
   

   
** assignmetns

   #+BEGIN_SRC ocaml
     a.(2)<-3;;
     Ptop_def
       [
         structure_item (//toplevel//[2,6+-6]..//toplevel//[2,6+2]) ghost
           Pstr_eval
           expression (//toplevel//[2,6+-6]..//toplevel//[2,6+2])
             Pexp_apply
             expression (//toplevel//[2,6+-6]..//toplevel//[2,6+2]) ghost
               Pexp_ident "Array.set"
             [
               <label> ""
                 expression (//toplevel//[2,6+-6]..//toplevel//[2,6+-5])
                   Pexp_ident "a"
               <label> ""
                 expression (//toplevel//[2,6+-3]..//toplevel//[2,6+-2])
                   Pexp_constant Const_int 2
               <label> ""
                 expression (//toplevel//[2,6+1]..//toplevel//[2,6+2])
                   Pexp_constant Const_int 3
             ]
       ]
   #+END_SRC


   #+BEGIN_SRC ocaml
     v.x<-2;;
     Ptop_def
       [
         structure_item (//toplevel//[2,6+-6]..//toplevel//[2,6+0]) ghost
           Pstr_eval
           expression (//toplevel//[2,6+-6]..//toplevel//[2,6+0])
             Pexp_setfield
             expression (//toplevel//[2,6+-6]..//toplevel//[2,6+-5])
               Pexp_ident "v"
             "x"
             expression (//toplevel//[2,6+-1]..//toplevel//[2,6+0])
               Pexp_constant Const_int 2
       ]
   #+END_SRC

   #+BEGIN_SRC ocaml
a.[1] <- 'a';;
Ptop_def
  [
    structure_item (//toplevel//[2,6+-6]..//toplevel//[3,14+12]) ghost
      Pstr_eval
      expression (//toplevel//[2,6+-6]..//toplevel//[3,14+12])
        Pexp_sequence
        expression (//toplevel//[2,6+-6]..//toplevel//[2,6+6])
          Pexp_apply
          expression (//toplevel//[2,6+-6]..//toplevel//[2,6+6]) ghost
            Pexp_ident "String.set"
          [
            <label> ""
              expression (//toplevel//[2,6+-6]..//toplevel//[2,6+-5])
                Pexp_ident "a"
            <label> ""
              expression (//toplevel//[2,6+-3]..//toplevel//[2,6+-2])
                Pexp_constant Const_int 1
            <label> ""
              expression (//toplevel//[2,6+3]..//toplevel//[2,6+6])
                Pexp_constant Const_char 61
          ]
        expression (//toplevel//[3,14+0]..//toplevel//[3,14+12])
          Pexp_apply
          expression (//toplevel//[3,14+0]..//toplevel//[3,14+12]) ghost
            Pexp_ident "String.set"
          [
            <label> ""
              expression (//toplevel//[3,14+0]..//toplevel//[3,14+1])
                Pexp_ident "a"
            <label> ""
              expression (//toplevel//[3,14+3]..//toplevel//[3,14+4])
                Pexp_constant Const_int 1
            <label> ""
              expression (//toplevel//[3,14+9]..//toplevel//[3,14+12])
                Pexp_constant Const_char 61
          ]
  ]
   #+END_SRC

** polymorphic syntax 
   file://localhost/Users/bobzhang1988/olibs/htmlman/manual021.html#xhtoc17
